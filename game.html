<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrum Sprint Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4F46E5',
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    }
                }
            }
        }
    </script>
    <style>
        /* Common text styles */
        .text-muted {
            @apply text-gray-700 dark:text-gray-300;
        }
        
        /* Card styles */
        .card {
            @apply bg-white dark:bg-gray-750 rounded-lg shadow p-4 border border-gray-200 dark:border-gray-700;
        }
        
        .card-hover {
            @apply hover:border-primary dark:hover:border-primary transition-all;
        }
        
        /* Button styles */
        .btn {
            @apply py-2 px-6 rounded-md transition-colors;
        }
        
        .btn-primary {
            @apply bg-primary text-white hover:bg-secondary;
        }
        
        .btn-secondary {
            @apply border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-700;
        }
        
        .btn-small {
            @apply py-1 px-4 text-sm;
        }
        
        /* Animations */
        .fade-in {
            animation: fadeIn 0.5s ease-in forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .dialog-animation {
            animation: fadeInUp 0.3s ease-out forwards;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .shake {
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        /* Transitions */
        .progress-bar {
            transition: width 0.5s ease-in-out;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .dark ::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        
        /* Badge styles */
        .skill-badge {
            @apply inline-block px-2 py-1 rounded-full text-xs;
        }
        
        .skill-frontend {
            @apply bg-green-100 text-green-800 dark:bg-green-900/50 dark:text-green-300;
        }
        
        .skill-backend {
            @apply bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300;
        }
        
        .skill-design {
            @apply bg-purple-100 text-purple-800 dark:bg-purple-900/50 dark:text-purple-300;
        }
        
        /* Section styles */
        .section-title {
            @apply text-lg font-semibold mb-2;
        }
        
        .panel {
            @apply bg-gray-50 dark:bg-gray-800/50 border border-gray-200 dark:border-gray-700 rounded-lg p-4;
        }
        
        .panel-blue {
            @apply bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg;
        }

        /* Chat bubble styles */
        .chat-bubble {
            @apply relative p-3 rounded-lg mb-3 max-w-[85%] text-sm;
        }
        
        .chat-bubble::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border: 8px solid transparent;
        }
        
        .chat-left {
            @apply bg-gray-100 dark:bg-gray-700 ml-2;
        }
        
        .chat-left::after {
            border-right-color: #f3f4f6;
            border-left: 0;
            left: -8px;
            top: 12px;
        }
        
        .dark .chat-left::after {
            border-right-color: #374151;
        }
        
        .chat-right {
            @apply bg-primary/10 text-primary ml-auto mr-2;
        }
        
        .chat-right::after {
            border-left-color: rgba(93, 92, 222, 0.1);
            border-right: 0;
            right: -8px;
            top: 12px;
        }
        
        /* Typing animation */
        .typing-animation {
            display: inline-flex;
            align-items: center;
            height: 17px;
        }
        
        .typing-dot {
            @apply bg-gray-500 dark:bg-gray-400;
            border-radius: 50%;
            width: 5px;
            height: 5px;
            margin: 0 1px;
            animation: typingAnimation 1.4s infinite ease-in-out;
        }
        
        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typingAnimation {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-3px); }
        }

        /* Kanban board styles */
        .kanban-board {
            @apply grid grid-cols-1 md:grid-cols-4 gap-3 overflow-auto;
            min-height: 300px;
        }

        .kanban-column {
            @apply bg-gray-50 dark:bg-gray-800 rounded-lg p-3 flex flex-col;
            min-width: 250px;
        }

        .kanban-column-header {
            @apply font-semibold mb-2 pb-2 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center;
        }

        .kanban-item {
            @apply bg-white dark:bg-gray-750 rounded border border-gray-200 dark:border-gray-700 p-3 mb-2 cursor-pointer;
        }

        /* Defect badges */
        .defect-high {
            @apply bg-red-100 text-red-800 dark:bg-red-900/50 dark:text-red-300;
        }
        
        .defect-medium {
            @apply bg-amber-100 text-amber-800 dark:bg-amber-900/50 dark:text-amber-300;
        }
        
        .defect-low {
            @apply bg-blue-100 text-blue-800 dark:bg-blue-900/50 dark:text-blue-300;
        }

        /* Carried over task style */
        .carried-over-badge {
            @apply bg-orange-100 text-orange-800 dark:bg-orange-900/50 dark:text-orange-300 inline-block px-2 py-1 rounded-full text-xs;
        }

        /* Rework badge */
        .rework-badge {
            @apply bg-rose-100 text-rose-800 dark:bg-rose-900/50 dark:text-rose-300 inline-block px-2 py-1 rounded-full text-xs;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-200">
    <div id="app" class="container mx-auto px-4 py-6 max-w-5xl">
        <!-- Game Header -->
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-bold mb-2 text-primary">Scrum Sprint Simulation</h1>
            <p class="text-gray-700 dark:text-gray-300">Lead your team through 3 sprints to deliver maximum value</p>
        </header>

        <!-- Game Content -->
        <main id="game-content" class="card mb-6">
            <!-- Content will be filled dynamically -->
            <div class="flex justify-center items-center h-64">
                <div class="text-center">
                    <div class="animate-pulse-slow mb-4">
                        <i class="fas fa-code text-primary text-4xl"></i>
                    </div>
                    <h2 class="text-xl font-semibold mb-2">Loading Game...</h2>
                    <p class="text-gray-700 dark:text-gray-300">Preparing your Scrum simulation experience</p>
                </div>
            </div>
        </main>

        <!-- Game Controls -->
        <footer class="text-center text-sm text-gray-700 dark:text-gray-300">
            <p class="mb-2">Scrum Sprint Simulation | Manage your team, deliver value, adapt to changes</p>
        </footer>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game State
        const gameState = {
            currentPhase: 'intro', // intro, teamSelection, backlogSelection, taskAssignment, sprintStrategy, sprint, definitionOfDone, retrospective, summary, final
            currentSprint: 0,
            totalSprints: 3,
            budget: 50000,
            team: [],
            backlog: [],
            selectedProducts: [],
            assignedTasks: {},
            sprintResults: [],
            sprintDay: 0,
            sprintLength: 14, // 14 days (default)
            events: [],
            currentEvent: null,
            selectedStrategies: [],
            teamMorale: 100,
            completedStoryPoints: 0,
            unassignedStoryPoints: 0,
            assignedStoryPoints: 0,
            finalScore: 0,
            retrospectiveDecisions: {
                sprintLength: 14, // Current sprint length
                teamChanges: false, // Whether team changes were recommended
                processChanges: false // Whether process changes were recommended
            },
            // New properties for task stages and defects
            taskStages: {}, // Maps productId to its current stage: 'backlog', 'inProgress', 'testing', 'done'
            taskDefects: {}, // Maps productId to an array of defects: {severity: 'high'|'medium'|'low', description: string}
            definitionOfDone: null, // Will store the selected definition of done after first sprint
            sprintEfficiency: 1.0, // Multiplier for sprint efficiency based on definition of done
            taskProgress: {}, // Maps productId to progress percentage in current stage
            lastStageUpdateDay: 0, // Last day when task stages were updated
            carriedOverTasks: [], // Tasks carried over from previous sprints with remaining points
            reworkCount: {} // Track number of times a task has been reworked
        };

        // Employee Types Data
        const employeeTypes = [
            {
                type: 'Frontend Engineer',
                levels: [
                    { level: 'Junior', cost: 5000, capacity: 5, efficiency: 0.8, icon: 'fa-solid fa-code' },
                    { level: 'Mid-level', cost: 8000, capacity: 8, efficiency: 1.0, icon: 'fa-solid fa-code' },
                    { level: 'Senior', cost: 12000, capacity: 10, efficiency: 1.2, icon: 'fa-solid fa-code' }
                ],
                skills: ['frontend']
            },
            {
                type: 'Backend Engineer',
                levels: [
                    { level: 'Junior', cost: 5500, capacity: 5, efficiency: 0.8, icon: 'fa-solid fa-database' },
                    { level: 'Mid-level', cost: 8500, capacity: 8, efficiency: 1.0, icon: 'fa-solid fa-database' },
                    { level: 'Senior', cost: 13000, capacity: 10, efficiency: 1.2, icon: 'fa-solid fa-database' }
                ],
                skills: ['backend']
            },
            {
                type: 'Full Stack Engineer',
                levels: [
                    { level: 'Junior', cost: 7000, capacity: 6, efficiency: 0.7, icon: 'fa-solid fa-laptop-code' },
                    { level: 'Mid-level', cost: 10000, capacity: 9, efficiency: 0.9, icon: 'fa-solid fa-laptop-code' },
                    { level: 'Senior', cost: 15000, capacity: 12, efficiency: 1.1, icon: 'fa-solid fa-laptop-code' }
                ],
                skills: ['frontend', 'backend']
            },
            {
                type: 'Designer',
                levels: [
                    { level: 'Junior', cost: 4500, capacity: 6, efficiency: 0.8, icon: 'fa-solid fa-palette' },
                    { level: 'Mid-level', cost: 7500, capacity: 9, efficiency: 1.0, icon: 'fa-solid fa-palette' },
                    { level: 'Senior', cost: 11000, capacity: 11, efficiency: 1.2, icon: 'fa-solid fa-palette' }
                ],
                skills: ['design']
            }
        ];

        // Product Backlog Data
        const productBacklogItems = [
            { 
                id: 1, 
                name: 'User Authentication', 
                description: 'User login and registration system with email verification', 
                storyPoints: 8, 
                skills: ['frontend', 'backend'] 
            },
            { 
                id: 2, 
                name: 'Landing Page', 
                description: 'Responsive landing page with animations and calls-to-action', 
                storyPoints: 5, 
                skills: ['frontend', 'design'] 
            },
            { 
                id: 3, 
                name: 'Product Catalog', 
                description: 'Browsable product listing with filters and sorting', 
                storyPoints: 13, 
                skills: ['frontend', 'backend'] 
            },
            { 
                id: 4, 
                name: 'Shopping Cart', 
                description: 'Add to cart functionality with quantity adjustment', 
                storyPoints: 8, 
                skills: ['frontend', 'backend'] 
            },
            { 
                id: 5, 
                name: 'User Dashboard', 
                description: 'Personal dashboard showing user activity and preferences', 
                storyPoints: 13, 
                skills: ['frontend', 'backend', 'design'] 
            },
            { 
                id: 6, 
                name: 'Payment Integration', 
                description: 'Secure payment processing with multiple providers', 
                storyPoints: 13, 
                skills: ['backend'] 
            },
            { 
                id: 7, 
                name: 'Admin Panel', 
                description: 'Administrative interface for managing users and content', 
                storyPoints: 20, 
                skills: ['frontend', 'backend'] 
            },
            { 
                id: 8, 
                name: 'Email Notifications', 
                description: 'Automated email system for order updates and marketing', 
                storyPoints: 5, 
                skills: ['backend'] 
            },
            { 
                id: 9, 
                name: 'Mobile Responsive Design', 
                description: 'Ensure all pages work perfectly on mobile devices', 
                storyPoints: 8, 
                skills: ['frontend', 'design'] 
            },
            { 
                id: 10, 
                name: 'Product Details Page', 
                description: 'Detailed product view with images, specs, and reviews', 
                storyPoints: 8, 
                skills: ['frontend', 'design'] 
            },
            { 
                id: 11, 
                name: 'Search Functionality', 
                description: 'Fast and accurate product search with autocomplete', 
                storyPoints: 8, 
                skills: ['frontend', 'backend'] 
            },
            { 
                id: 12, 
                name: 'User Reviews', 
                description: 'Allow users to rate and review products', 
                storyPoints: 5, 
                skills: ['frontend', 'backend'] 
            }
        ];

        // Team Strategies
        const teamStrategies = [
            { 
                id: 'focusQuality', 
                name: 'Focus on Quality', 
                description: 'Higher quality but slower development',
                effect: 'Reduces story points but increases quality score'
            },
            { 
                id: 'focusSpeed', 
                name: 'Focus on Speed', 
                description: 'Faster development but may introduce bugs',
                effect: 'Increases story points but reduces quality score'
            },
            { 
                id: 'pairProgramming', 
                name: 'Pair Programming', 
                description: 'Engineers work in pairs for better collaboration',
                effect: 'Slight reduction in story points but increases team learning'
            },
            { 
                id: 'codeTesting', 
                name: 'Intensive Testing', 
                description: 'Allocate more time to testing and QA',
                effect: 'Fewer story points completed but higher quality'
            },
            { 
                id: 'dailyMeetings', 
                name: 'Extra Stand-ups', 
                description: 'Additional daily meetings to improve coordination',
                effect: 'Better communication but slightly fewer story points'
            },
            { 
                id: 'overtime', 
                name: 'Optional Overtime', 
                description: 'Team members can work extra hours if they choose',
                effect: 'More story points but decreases team morale'
            }
        ];

        // Random Events
        const sprintEvents = [
            {
                id: 'sickDay',
                title: 'Team Member Sick',
                description: 'One of your team members has called in sick today.',
                impact: 'Reduced capacity for the day',
                dialogues: [
                    { speaker: 'Team Lead', message: 'Hey team, just heard that [name] is sick today. Let\'s adjust our tasks.' },
                    { speaker: 'Team Member', message: 'I hope they feel better soon. Should we redistribute their tasks?' }
                ],
                options: [
                    { 
                        id: 'redistribute', 
                        text: 'Redistribute Tasks', 
                        effect: 'Other team members pick up slack, slight reduction in overall productivity' 
                    },
                    { 
                        id: 'postpone', 
                        text: 'Postpone Tasks', 
                        effect: 'Fewer story points completed today but no added pressure on team' 
                    }
                ]
            },
            {
                id: 'techIssue',
                title: 'Technical Difficulties',
                description: 'Your development environment is having issues today.',
                impact: 'Reduced productivity across team',
                dialogues: [
                    { speaker: 'Developer', message: 'The build server is down again! I can\'t test my changes.' },
                    { speaker: 'DevOps', message: 'We\'re looking into it. Should be fixed in a few hours.' }
                ],
                options: [
                    { 
                        id: 'focusLocal', 
                        text: 'Focus on Local Development', 
                        effect: 'Continue working but with limited integration testing' 
                    },
                    { 
                        id: 'documentCode', 
                        text: 'Document Code & Plan', 
                        effect: 'Use time for documentation instead, minimal story point progress' 
                    }
                ]
            },
            {
                id: 'newRequirement',
                title: 'New Requirements',
                description: 'The client has requested a new feature mid-sprint.',
                impact: 'Potential scope changes',
                dialogues: [
                    { speaker: 'Product Owner', message: 'The client just emailed me about adding a new feature they need ASAP.' },
                    { speaker: 'Scrum Master', message: 'That\'s not how Scrum works. We should discuss this in the next planning meeting.' }
                ],
                options: [
                    { 
                        id: 'negotiate', 
                        text: 'Negotiate Scope', 
                        effect: 'Try to defer new requirements to next sprint' 
                    },
                    { 
                        id: 'accommodate', 
                        text: 'Accommodate Changes', 
                        effect: 'Add new requirements but risk not completing sprint goals' 
                    }
                ]
            },
            {
                id: 'teamConflict',
                title: 'Team Disagreement',
                description: 'Two team members are having a disagreement about implementation approach.',
                impact: 'Potential productivity loss and morale impact',
                dialogues: [
                    { speaker: 'Developer 1', message: 'I think we should use the new framework, it\'s much more efficient.' },
                    { speaker: 'Developer 2', message: 'That would require rewriting too much code. Let\'s stick with what we know.' }
                ],
                options: [
                    { 
                        id: 'codeReview', 
                        text: 'Hold Team Code Review', 
                        effect: 'Slower today but better alignment going forward' 
                    },
                    { 
                        id: 'splitWork', 
                        text: 'Split the Work', 
                        effect: 'Each developer works independently, may cause integration issues later' 
                    }
                ]
            },
            {
                id: 'inspiration',
                title: 'Creative Inspiration',
                description: 'Your designer has a brilliant idea for improving the UI.',
                impact: 'Potential quality improvement',
                dialogues: [
                    { speaker: 'Designer', message: 'I had this amazing idea last night that could make the interface much more intuitive!' },
                    { speaker: 'Team Lead', message: 'That sounds great, but we need to consider our current sprint commitments.' }
                ],
                options: [
                    { 
                        id: 'implementNow', 
                        text: 'Implement New Design', 
                        effect: 'Higher quality but might delay some features' 
                    },
                    { 
                        id: 'documentForLater', 
                        text: 'Document for Later', 
                        effect: 'Stay on schedule but miss immediate improvement opportunity' 
                    }
                ]
            },
            {
                id: 'expertHelp',
                title: 'Expert Consultation',
                description: 'A senior architect is available to help your team today.',
                impact: 'Potential productivity boost',
                dialogues: [
                    { speaker: 'Scrum Master', message: 'Great news! Sarah from architecture is free today and offered to help us.' },
                    { speaker: 'Developer', message: 'Awesome! She could help us solve that persistent issue we\'ve been facing.' }
                ],
                options: [
                    { 
                        id: 'focusTechnical', 
                        text: 'Focus on Technical Debt', 
                        effect: 'Solve long-standing issues but fewer new features today' 
                    },
                    { 
                        id: 'speedFeature', 
                        text: 'Accelerate Key Feature', 
                        effect: 'Complete a difficult feature faster than planned' 
                    }
                ]
            }
        ];

        // Definition of Done options
        const definitionOfDoneOptions = [
            {
                id: 'strict', 
                text: 'No more than one medium and two low-severity defects',
                description: 'Strict quality standards may reduce velocity initially but lead to less rework',
                effect: { efficiency: 0.9, qualityBoost: 15 }
            },
            {
                id: 'balanced', 
                text: 'No more than two medium and two low-severity defects',
                description: 'Balanced approach between quality and speed',
                effect: { efficiency: 1.0, qualityBoost: 5 }
            },
            {
                id: 'selective', 
                text: 'No more than one medium or two low-severity defects',
                description: 'Focus on eliminating medium defects',
                effect: { efficiency: 0.95, qualityBoost: 10 }
            },
            {
                id: 'lenient', 
                text: 'No more than three total medium or low-severity defects',
                description: 'More lenient standards to optimize for speed',
                effect: { efficiency: 1.1, qualityBoost: -5 }
            }
        ];

        // Defect types
        const defectTypes = {
            high: [
                "Critical security vulnerability",
                "Application crashes on key action",
                "Data corruption issue",
                "Payment processing error",
                "Authentication bypass vulnerability",
                "Incorrect calculation of core business logic",
                "Session handling issue",
                "Database connection failure",
                "Memory leak causing performance degradation",
                "Critical API integration failure"
            ],
            medium: [
                "UI inconsistency across browsers",
                "Form validation issue",
                "Minor calculation error",
                "Performance issue on specific page",
                "Error handling improvement needed",
                "Pagination issue",
                "Sorting functionality not working as expected",
                "Search results inconsistency",
                "Mobile responsiveness issue",
                "Filter functionality partially working"
            ],
            low: [
                "Typo in user interface",
                "Minor UI alignment issue",
                "Non-critical console warning",
                "Cosmetic issue in rarely used feature",
                "Minor color inconsistency",
                "Incomplete error message",
                "Non-critical documentation error",
                "Edge case handling improvement",
                "Minor accessibility issue",
                "Small UI element spacing issue"
            ]
        };

        // Name database for random employee names
        const firstNames = ["Alex", "Jamie", "Morgan", "Taylor", "Jordan", "Casey", "Riley", "Avery", "Quinn", "Blake", "Sam", "Chris", "Pat", "Jesse", "Skyler", "Cameron", "Reese", "Finley"];
        const lastNames = ["Smith", "Johnson", "Lee", "Garcia", "Martinez", "Chen", "Patel", "Walker", "Kim", "Robinson", "Thompson", "Wright", "Nguyen", "Lopez", "Hill", "Green", "Adams", "Baker"];

        // Helper function to generate a unique employee name
        function generateEmployeeName() {
            const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
            const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
            return `${firstName} ${lastName}`;
        }

        // Helper function to format currency
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', maximumFractionDigits: 0 }).format(amount);
        }

        // Helper function to generate a unique ID
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }

        // Helper function to shuffle array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Helper function to get skill badge HTML
        function getSkillBadgeHtml(skill) {
            return `<span class="skill-badge skill-${skill}">${skill}</span>`;
        }

        // Helper function to get defect badge HTML
        function getDefectBadgeHtml(severity) {
            return `<span class="skill-badge defect-${severity}">${severity}</span>`;
        }

        // Helper function to calculate total assigned points for a product
        function getProductAssignedPoints(productId) {
            return Object.values(gameState.assignedTasks).flat()
                .filter(task => task.id === productId)
                .reduce((sum, task) => sum + task.storyPoints, 0);
        }

        // Helper function to get remaining points for a product
        function getProductRemainingPoints(productId) {
            const product = gameState.selectedProducts.find(p => p.id === productId);
            const assignedPoints = getProductAssignedPoints(productId);
            return product.storyPoints - assignedPoints;
        }

        // Helper function to generate random defects for a task
        function generateDefects(productId) {
            const defects = [];
            const product = gameState.selectedProducts.find(p => p.id === productId);
            
            // Base chance of defects
            let highDefectChance = 0.15;
            let mediumDefectChance = 0.3;
            let lowDefectChance = 0.4;
            
            // Apply modifiers based on strategies
            if (gameState.selectedStrategies.includes('focusQuality')) {
                highDefectChance *= 0.5;
                mediumDefectChance *= 0.7;
                lowDefectChance *= 0.8;
            }
            
            if (gameState.selectedStrategies.includes('focusSpeed')) {
                highDefectChance *= 1.5;
                mediumDefectChance *= 1.3;
                lowDefectChance *= 1.2;
            }
            
            if (gameState.selectedStrategies.includes('codeTesting')) {
                highDefectChance *= 0.6;
                mediumDefectChance *= 0.8;
                lowDefectChance *= 0.9;
            }
            
            // More complex products have more chance for defects
            const complexityFactor = Math.min(1.5, 1 + (product.storyPoints / 20));
            highDefectChance *= complexityFactor;
            mediumDefectChance *= complexityFactor;
            lowDefectChance *= complexityFactor;
            
            // Rework factor: each rework reduces the chance of defects
            const reworkCount = gameState.reworkCount[productId] || 0;
            if (reworkCount > 0) {
                const reworkFactor = Math.max(0.3, 1 - (reworkCount * 0.2));
                highDefectChance *= reworkFactor;
                mediumDefectChance *= reworkFactor;
                lowDefectChance *= reworkFactor;
            }
            
            // Generate defects
            if (Math.random() < highDefectChance) {
                defects.push({
                    severity: 'high',
                    description: defectTypes.high[Math.floor(Math.random() * defectTypes.high.length)]
                });
            }
            
            // Can have up to 2 medium defects
            const mediumDefectCount = Math.random() < mediumDefectChance ? 
                (Math.random() < 0.4 ? 2 : 1) : 0;
            
            for (let i = 0; i < mediumDefectCount; i++) {
                defects.push({
                    severity: 'medium',
                    description: defectTypes.medium[Math.floor(Math.random() * defectTypes.medium.length)]
                });
            }
            
            // Can have up to 3 low defects
            const lowDefectCount = Math.random() < lowDefectChance ? 
                (Math.random() < 0.3 ? (Math.random() < 0.5 ? 3 : 2) : 1) : 0;
            
            for (let i = 0; i < lowDefectCount; i++) {
                defects.push({
                    severity: 'low',
                    description: defectTypes.low[Math.floor(Math.random() * defectTypes.low.length)]
                });
            }
            
            return defects;
        }

        // Helper function to check if task meets Definition of Done criteria
        function meetsDefinitionOfDone(productId) {
            if (!gameState.definitionOfDone) return true; // No DoD set yet
            
            const defects = gameState.taskDefects[productId] || [];
            const highDefects = defects.filter(d => d.severity === 'high').length;
            const mediumDefects = defects.filter(d => d.severity === 'medium').length;
            const lowDefects = defects.filter(d => d.severity === 'low').length;
            
            // All definitions require no high-severity defects
            if (highDefects > 0) return false;
            
            switch (gameState.definitionOfDone.id) {
                case 'strict':
                    return mediumDefects <= 1 && lowDefects <= 2;
                case 'balanced':
                    return mediumDefects <= 2 && lowDefects <= 2;
                case 'selective':
                    return mediumDefects <= 1 || lowDefects <= 2;
                case 'lenient':
                    return (mediumDefects + lowDefects) <= 3;
                default:
                    return true;
            }
        }

        // Helper function to calculate remaining story points for a product based on progress
        function calculateRemainingStoryPoints(productId) {
            const product = gameState.selectedProducts.find(p => p.id === productId);
            if (!product) return 0;
            
            const totalPoints = product.storyPoints;
            const stage = gameState.taskStages[productId];
            const progress = gameState.taskProgress[productId] || 0;
            
            // For tasks in "done" stage, there are no remaining points
            if (stage === 'done') {
                return 0;
            }
            
            // For tasks in other stages, calculate based on progress:
            // - Backlog: 100% of points remain
            // - In Progress: Points remaining = total * (1 - progress/100)
            // - Testing: Small percentage remaining (10-20%)
            
            if (stage === 'backlog') {
                return totalPoints;
            } else if (stage === 'inProgress') {
                return Math.round(totalPoints * (1 - progress/100));
            } else if (stage === 'testing') {
                // If testing is close to done, only small amount remains
                if (progress > 80) {
                    return Math.max(1, Math.round(totalPoints * 0.1)); // At least 1 point remains
                } else {
                    return Math.round(totalPoints * (0.2 - (progress/100) * 0.1));
                }
            }
            
            return totalPoints; // Default fallback
        }

        // Helper function to send a task back for rework
        function reworkTask(productId) {
            // Check if the task is in testing stage
            if (gameState.taskStages[productId] !== 'testing') {
                return false;
            }
            
            // Update rework count
            if (!gameState.reworkCount[productId]) {
                gameState.reworkCount[productId] = 1;
            } else {
                gameState.reworkCount[productId]++;
            }
            
            // Move the task back to In Progress stage
            gameState.taskStages[productId] = 'inProgress';
            
            // Reset progress (start at 50% since it's being reworked)
            gameState.taskProgress[productId] = 50;
            
            // Clear existing defects and generate new ones
            delete gameState.taskDefects[productId];
            
            // Defects will be regenerated when task is moved back to testing
            
            return true;
        }

        // Initialize the game
        function initializeGame() {
            // Initialize backlog with random story points
            gameState.backlog = [...productBacklogItems];
            
            // Reset game state
            gameState.team = [];
            gameState.selectedProducts = [];
            gameState.assignedTasks = {};
            gameState.sprintResults = [];
            gameState.currentSprint = 0;
            gameState.budget = 50000;
            gameState.sprintDay = 0;
            gameState.events = [];
            gameState.currentEvent = null;
            gameState.teamMorale = 100;
            gameState.completedStoryPoints = 0;
            gameState.unassignedStoryPoints = 0;
            gameState.assignedStoryPoints = 0;
            gameState.selectedStrategies = [];
            gameState.finalScore = 0;
            gameState.retrospectiveDecisions = {
                sprintLength: 14,
                teamChanges: false,
                processChanges: false
            };
            
            // Reset task stages and defects
            gameState.taskStages = {};
            gameState.taskDefects = {};
            gameState.definitionOfDone = null;
            gameState.sprintEfficiency = 1.0;
            gameState.taskProgress = {};
            gameState.lastStageUpdateDay = 0;
            gameState.carriedOverTasks = [];
            gameState.reworkCount = {};
            
            // Start with intro phase
            renderPhase('intro');
        }

        function reset_sprint_len() {
            gameState.sprintLength = 14;
            gameState.retrospectiveDecisions.sprintLength = 14;
        }
        
        // Render the current game phase
        function renderPhase(phase) {
            if (phase) {
                gameState.currentPhase = phase;
            }
            
            const gameContent = document.getElementById('game-content');
            gameContent.innerHTML = '';
            
            switch (gameState.currentPhase) {
                case 'intro':
                    renderIntroPhase(gameContent);
                    break;
                case 'teamSelection':
                    renderTeamSelectionPhase(gameContent);
                    break;
                case 'backlogSelection':
                    renderBacklogSelectionPhase(gameContent);
                    break;
                case 'taskAssignment':
                    renderTaskAssignmentPhase(gameContent);
                    break;
                case 'sprintStrategy':
                    renderSprintStrategyPhase(gameContent);
                    break;
                case 'sprint':
                    renderSprintPhase(gameContent);
                    break;
                case 'definitionOfDone':
                    renderDefinitionOfDonePhase(gameContent);
                    break;
                case 'retrospective':
                    renderRetrospectivePhase(gameContent);
                    break;
                case 'summary':
                    renderSprintSummaryPhase(gameContent);
                    break;
                case 'final':
                    renderFinalSummaryPhase(gameContent);
                    break;
                default:
                    renderIntroPhase(gameContent);
            }
        }

        // Render Introduction Phase
        function renderIntroPhase(container) {
            container.innerHTML = `
                <div class="text-center max-w-3xl mx-auto fade-in">
                    <div class="mb-6">
                        <i class="fas fa-users-cog text-primary text-5xl mb-4"></i>
                        <h2 class="text-2xl font-bold mb-4">Welcome to Scrum Sprint Simulation!</h2>
                        <p class="mb-4">You'll lead a development team through 3 sprints, making strategic decisions to maximize your delivery.</p>
                        
                        <div class="panel-blue text-left mb-6">
                            <h3 class="font-bold mb-2 text-blue-700 dark:text-blue-300">How to Play:</h3>
                            <ol class="list-decimal list-inside space-y-1 text-blue-800 dark:text-blue-200">
                                <li>Hire your team with a budget of ${formatCurrency(gameState.budget)}</li>
                                <li>Select products from the backlog for each sprint</li>
                                <li>Assign tasks to team members based on their skills</li>
                                <li>Choose team strategies and respond to events during the sprint</li>
                                <li>Track tasks through Backlog, In Progress, Testing, and Done stages</li>
                                <li>Manage product defects according to your Definition of Done</li>
                                <li>Participate in sprint retrospectives to improve your process</li>
                                <li>Review your team's performance after each sprint</li>
                            </ol>
                        </div>
                        
                        <p class="mb-6">Your objective is to complete as many story points as possible while maintaining high quality and team morale.</p>
                        
                        <button id="start-game" class="btn btn-primary transform hover:scale-105">
                            Start Your Journey as Scrum Master
                        </button>
                    </div>
                </div>
            `;
            
            document.getElementById('start-game').addEventListener('click', () => {
                renderPhase('teamSelection');
            });
        }

        // Render Team Selection Phase
        function renderTeamSelectionPhase(container) {
            let employeeCards = '';
            
            employeeTypes.forEach(type => {
                employeeCards += `
                    <div class="mb-6">
                        <h3 class="section-title text-primary">${type.type}</h3>
                        <div class="grid md:grid-cols-3 gap-4">
                `;
                
                type.levels.forEach(level => {
                    const id = `${type.type.toLowerCase().replace(/\s/g, '-')}-${level.level.toLowerCase()}`;
                    employeeCards += `
                        <div class="card card-hover">
                            <div class="flex justify-between items-start mb-3">
                                <div>
                                    <span class="text-sm font-semibold">${level.level}</span>
                                    <h4 class="font-bold">${type.type}</h4>
                                </div>
                                <div class="text-xl text-primary">
                                    <i class="${level.icon}"></i>
                                </div>
                            </div>
                            <div class="space-y-2 mb-4 text-sm">
                                <div class="flex justify-between">
                                    <span class="text-gray-700 dark:text-gray-300">Cost:</span>
                                    <span class="font-semibold">${formatCurrency(level.cost)}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-700 dark:text-gray-300">Capacity:</span>
                                    <span class="font-semibold">${level.capacity} points</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-700 dark:text-gray-300">Efficiency:</span>
                                    <span class="font-semibold">${level.efficiency.toFixed(1)}x</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-700 dark:text-gray-300">Skills:</span>
                                    <span class="font-semibold">${type.skills.join(', ')}</span>
                                </div>
                            </div>
                            <button 
                                class="hire-employee w-full py-2 px-4 rounded-md bg-primary text-white hover:bg-secondary transition-colors"
                                data-type="${type.type}"
                                data-level="${level.level}"
                                data-id="${id}"
                            >
                                Hire
                            </button>
                        </div>
                    `;
                });
                
                employeeCards += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Build Your Team</h2>
                            <p class="text-gray-700 dark:text-gray-300">Hire team members within your budget</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-semibold">
                                Budget: <span id="remaining-budget">${formatCurrency(gameState.budget)}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="section-title">Your Team</h3>
                        <div id="selected-team" class="panel min-h-[100px]">
                            ${gameState.team.length === 0 ? 
                                '<p class="text-gray-700 dark:text-gray-300 text-center italic">Your hired team members will appear here</p>' : ''}
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="section-title mb-4">Available Employees</h3>
                        ${employeeCards}
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="reset-team" class="btn btn-secondary">
                            Reset Team
                        </button>
                        <button id="continue-to-backlog" class="btn btn-primary ${gameState.team.length === 0 ? 'opacity-50 cursor-not-allowed' : ''}">
                            Continue to Backlog
                        </button>
                    </div>
                </div>
            `;
            
            // Update selected team display
            updateSelectedTeam();
            
            // Add event listeners
            const hireButtons = document.querySelectorAll('.hire-employee');
            hireButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const type = button.getAttribute('data-type');
                    const level = button.getAttribute('data-level');
                    hireEmployee(type, level);
                });
            });
            
            document.getElementById('reset-team').addEventListener('click', () => {
                gameState.team = [];
                gameState.budget = 50000;
                updateSelectedTeam();
                updateHireButtons();
            });
            
            document.getElementById('continue-to-backlog').addEventListener('click', () => {
                if (gameState.team.length > 0) {
                    renderPhase('backlogSelection');
                } else {
                    showNotification('Please hire at least one team member to continue', 'error');
                }
            });
        }

        // Update display of selected team members
        function updateSelectedTeam() {
            const teamContainer = document.getElementById('selected-team');
            const budgetDisplay = document.getElementById('remaining-budget');
            
            if (budgetDisplay) {
                budgetDisplay.textContent = formatCurrency(gameState.budget);
            }
            
            if (teamContainer) {
                if (gameState.team.length === 0) {
                    teamContainer.innerHTML = '<p class="text-gray-700 dark:text-gray-300 text-center italic">Your hired team members will appear here</p>';
                    return;
                }
                
                let teamHtml = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
                
                gameState.team.forEach(employee => {
                    teamHtml += `
                        <div class="card flex justify-between items-center">
                            <div class="flex items-center">
                                <div class="text-xl text-primary mr-3">
                                    <i class="${employee.icon}"></i>
                                </div>
                                <div>
                                    <div class="font-semibold">${employee.name}</div>
                                    <div class="text-sm text-gray-700 dark:text-gray-300">${employee.level} ${employee.type}</div>
                                </div>
                            </div>
                            <button class="fire-employee text-red-500 hover:text-red-700 dark:hover:text-red-400 p-1" data-id="${employee.id}">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    `;
                });
                
                teamHtml += '</div>';
                teamContainer.innerHTML = teamHtml;
                
                // Add event listeners for fire buttons
                const fireButtons = document.querySelectorAll('.fire-employee');
                fireButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const employeeId = button.getAttribute('data-id');
                        fireEmployee(employeeId);
                    });
                });
            }
            
            updateHireButtons();
        }

        // Update hire buttons based on remaining budget
        function updateHireButtons() {
            const hireButtons = document.querySelectorAll('.hire-employee');
            
            hireButtons.forEach(button => {
                const type = button.getAttribute('data-type');
                const level = button.getAttribute('data-level');
                
                // Find the employee cost
                const employeeType = employeeTypes.find(t => t.type === type);
                const employeeLevel = employeeType.levels.find(l => l.level === level);
                const cost = employeeLevel.cost;
                
                // Disable button if not enough budget
                if (cost > gameState.budget) {
                    button.disabled = true;
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                    button.classList.remove('hover:bg-secondary');
                } else {
                    button.disabled = false;
                    button.classList.remove('opacity-50', 'cursor-not-allowed');
                    button.classList.add('hover:bg-secondary');
                }
            });
            
            // Update continue button state
            const continueButton = document.getElementById('continue-to-backlog');
            if (continueButton) {
                if (gameState.team.length === 0) {
                    continueButton.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    continueButton.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // Hire an employee
        function hireEmployee(type, level) {
            // Find employee data
            const employeeType = employeeTypes.find(t => t.type === type);
            const employeeLevel = employeeType.levels.find(l => l.level === level);
            
            // Check if enough budget
            if (employeeLevel.cost > gameState.budget) {
                showNotification('Not enough budget to hire this employee', 'error');
                return;
            }
            
            // Create new employee
            const newEmployee = {
                id: generateId(),
                name: generateEmployeeName(),
                type: type,
                level: level,
                cost: employeeLevel.cost,
                capacity: employeeLevel.capacity,
                efficiency: employeeLevel.efficiency,
                skills: [...employeeType.skills],
                icon: employeeLevel.icon,
                remainingCapacity: employeeLevel.capacity
            };
            
            // Add to team and update budget
            gameState.team.push(newEmployee);
            gameState.budget -= employeeLevel.cost;
            
            // Update UI
            updateSelectedTeam();
            showNotification(`${newEmployee.name} (${level} ${type}) has joined your team!`, 'success');
        }

        // Fire an employee
        function fireEmployee(employeeId) {
            const employeeIndex = gameState.team.findIndex(e => e.id === employeeId);
            if (employeeIndex !== -1) {
                const employee = gameState.team[employeeIndex];
                gameState.budget += employee.cost;
                gameState.team.splice(employeeIndex, 1);
                updateSelectedTeam();
                showNotification(`${employee.name} has been removed from your team`, 'info');
            }
        }

        // Render Backlog Selection Phase
        function renderBacklogSelectionPhase(container) {
            // Reset selections for this sprint (but keep carried over tasks)
            gameState.selectedProducts = [...gameState.carriedOverTasks];
            
            // Get available backlog items (not completed in previous sprints and not carried over)
            const completedProductIds = gameState.sprintResults.flatMap(result => 
                result.completedProducts.map(product => product.id)
            );
            
            const carriedOverIds = gameState.carriedOverTasks.map(task => task.id);
            
            const availableBacklog = gameState.backlog.filter(item => 
                !completedProductIds.includes(item.id) && !carriedOverIds.includes(item.id)
            );
            
            // Shuffle available backlog for variety
            const shuffledBacklog = shuffleArray([...availableBacklog]);
            
            // Only show 6 items per sprint for simplicity
            const backlogToShow = shuffledBacklog.slice(0, 8);
            
            let backlogItems = '';
            backlogToShow.forEach(item => {
                const skillBadges = item.skills.map(skill => getSkillBadgeHtml(skill)).join(' ');
                
                backlogItems += `
                    <div class="backlog-item card card-hover">
                        <div class="flex justify-between items-start mb-3">
                            <h4 class="font-bold">${item.name}</h4>
                            <div class="text-white bg-primary rounded-full w-8 h-8 flex items-center justify-center font-bold">
                                ${item.storyPoints}
                            </div>
                        </div>
                        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">${item.description}</p>
                        <div class="mb-3 space-x-1">
                            ${skillBadges}
                        </div>
                        <button 
                            class="select-product w-full py-2 px-4 rounded-md bg-gray-100 dark:bg-gray-700 hover:bg-primary hover:text-white transition-colors"
                            data-id="${item.id}"
                        >
                            Select
                        </button>
                    </div>
                `;
            });
            
            // Show carried over tasks section if there are any
            let carriedOverSection = '';
            if (gameState.carriedOverTasks.length > 0) {
                let carriedOverItems = '';
                gameState.carriedOverTasks.forEach(task => {
                    const skillBadges = task.skills.map(skill => getSkillBadgeHtml(skill)).join(' ');
                    carriedOverItems += `
                        <div class="card">
                            <div class="flex justify-between items-start mb-2">
                                <div>
                                    <h4 class="font-bold">${task.name}</h4>
                                    <div class="mt-1">
                                        <span class="carried-over-badge">Carried Over</span>
                                    </div>
                                </div>
                                <div class="text-white bg-primary rounded-full w-8 h-8 flex items-center justify-center font-bold">
                                    ${task.remainingPoints}
                                </div>
                            </div>
                            <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">${task.description}</p>
                            <div class="mb-2 space-x-1">
                                ${skillBadges}
                            </div>
                            <div class="text-amber-600 dark:text-amber-400 text-sm">
                                <i class="fas fa-exclamation-circle mr-1"></i> Must be completed in this sprint
                            </div>
                        </div>
                    `;
                });
                
                carriedOverSection = `
                    <div class="mb-6">
                        <h3 class="section-title">Carried Over Tasks</h3>
                        <div class="text-sm text-gray-700 dark:text-gray-300 mb-3">
                            These incomplete tasks from the previous sprint must be completed first.
                        </div>
                        <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                            ${carriedOverItems}
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Select Product Backlog</h2>
                            <p class="text-gray-700 dark:text-gray-300">Choose at least 3 products for Sprint ${gameState.currentSprint + 1}</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-semibold">
                                Selected: <span id="selected-count">0</span> / 8
                            </div>
                        </div>
                    </div>
                    
                    ${carriedOverSection}
                    
                    <div class="mb-6">
                        <h3 class="section-title">Selected Products</h3>
                        <div id="selected-products" class="panel min-h-[100px]">
                            <p class="text-gray-700 dark:text-gray-300 text-center italic">Your selected products will appear here</p>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="section-title mb-4">Available Products</h3>
                        <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
                            ${backlogItems}
                        </div>
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="back-to-team" class="btn btn-secondary">
                            Back to Team
                        </button>
                        <button id="continue-to-tasks" class="btn btn-primary ${
                            gameState.selectedProducts.length + gameState.carriedOverTasks.length >= 3 ? '' : 'opacity-50 cursor-not-allowed'
                        }">
                            Continue to Task Assignment
                        </button>
                    </div>
                </div>
            `;
            
            // Update the selected products display
            updateSelectedProducts();
            
            // Add event listeners
            const selectButtons = document.querySelectorAll('.select-product');
            selectButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const productId = parseInt(button.getAttribute('data-id'));
                    toggleProductSelection(productId, backlogToShow);
                });
            });
            
            document.getElementById('back-to-team').addEventListener('click', () => {
                renderPhase('teamSelection');
            });
            
            document.getElementById('continue-to-tasks').addEventListener('click', () => {
                if (gameState.selectedProducts.length >= 3 || 
                    (gameState.selectedProducts.length + gameState.carriedOverTasks.length >= 3)) {
                    renderPhase('taskAssignment');
                } else {
                    showNotification('Please select at least 3 products to continue', 'error');
                }
            });
        }

        // Toggle product selection
        function toggleProductSelection(productId, availableProducts) {
            const selectedIndex = gameState.selectedProducts.findIndex(p => p.id === productId);
            const product = availableProducts.find(p => p.id === productId);
            
            if (selectedIndex === -1) {
                // Add product
                gameState.selectedProducts.push(product);
            } else {
                // Remove product (only if it's not a carried over task)
                if (!gameState.carriedOverTasks.some(t => t.id === productId)) {
                    gameState.selectedProducts.splice(selectedIndex, 1);
                } else {
                    showNotification('Cannot remove a carried over task', 'error');
                }
            }
            
            updateSelectedProducts();
        }

        // Update display of selected products
        function updateSelectedProducts() {
            const productsContainer = document.getElementById('selected-products');
            const countDisplay = document.getElementById('selected-count');
            const continueButton = document.getElementById('continue-to-tasks');
            
            if (countDisplay) {
                countDisplay.textContent = gameState.selectedProducts.length;
            }
            
            if (productsContainer) {
                if (gameState.selectedProducts.length === 0) {
                    productsContainer.innerHTML = '<p class="text-gray-700 dark:text-gray-300 text-center italic">Your selected products will appear here</p>';
                } else {
                    let productsHtml = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">';
                    
                    gameState.selectedProducts.forEach(product => {
                        const skillBadges = product.skills.map(skill => getSkillBadgeHtml(skill)).join(' ');
                        const isCarriedOver = gameState.carriedOverTasks.some(t => t.id === product.id);
                        const pointsToShow = isCarriedOver ? 
                            gameState.carriedOverTasks.find(t => t.id === product.id).remainingPoints : 
                            product.storyPoints;
                        
                        productsHtml += `
                            <div class="card flex flex-col">
                                <div class="flex justify-between items-start mb-2">
                                    <div>
                                        <h4 class="font-semibold">${product.name}</h4>
                                        ${isCarriedOver ? '<div class="mt-1"><span class="carried-over-badge">Carried Over</span></div>' : ''}
                                    </div>
                                    <div class="text-white bg-primary rounded-full w-6 h-6 flex items-center justify-center font-bold text-sm">
                                        ${pointsToShow}
                                    </div>
                                </div>
                                <div class="mb-2 space-x-1">
                                    ${skillBadges}
                                </div>
                                ${!isCarriedOver ? `
                                <button class="remove-product text-red-500 hover:text-red-700 dark:hover:text-red-400 mt-auto self-end" data-id="${product.id}">
                                    Remove
                                </button>
                                ` : '<div class="text-xs text-amber-600 dark:text-amber-400 mt-auto">Must be completed this sprint</div>'}
                            </div>
                        `;
                    });
                    
                    productsHtml += '</div>';
                    productsContainer.innerHTML = productsHtml;
                    
                    // Add event listeners for remove buttons
                    const removeButtons = document.querySelectorAll('.remove-product');
                    removeButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const productId = parseInt(button.getAttribute('data-id'));
                            const selectedIndex = gameState.selectedProducts.findIndex(p => p.id === productId);
                            if (selectedIndex !== -1) {
                                gameState.selectedProducts.splice(selectedIndex, 1);
                                updateSelectedProducts();
                            }
                        });
                    });
                }
            }
            
            // Update continue button state
            if (continueButton) {
                if (gameState.selectedProducts.length >= 3 || 
                    (gameState.selectedProducts.length + gameState.carriedOverTasks.length >= 3)) {
                    continueButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    continueButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }
            
            // Update select buttons
            const selectButtons = document.querySelectorAll('.select-product');
            selectButtons.forEach(button => {
                const productId = parseInt(button.getAttribute('data-id'));
                const isSelected = gameState.selectedProducts.some(p => p.id === productId);
                
                if (isSelected) {
                    button.textContent = 'Selected';
                    button.classList.add('bg-primary', 'text-white');
                    button.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'hover:bg-primary');
                } else {
                    button.textContent = 'Select';
                    button.classList.remove('bg-primary', 'text-white');
                    button.classList.add('bg-gray-100', 'dark:bg-gray-700', 'hover:bg-primary', 'hover:text-white');
                }
            });
        }

        // Render Task Assignment Phase
        function renderTaskAssignmentPhase(container) {
            // Reset task assignments
            gameState.assignedTasks = {};
            gameState.team.forEach(employee => {
                employee.remainingCapacity = employee.capacity;
                gameState.assignedTasks[employee.id] = [];
            });
            
            // Reset task stages and defects for this sprint (except for carried over tasks)
            const carriedOverIds = gameState.carriedOverTasks.map(task => task.id);
            
            // Initialize all selected products as 'backlog' (unless they're carried over)
            gameState.selectedProducts.forEach(product => {
                const isCarriedOver = carriedOverIds.includes(product.id);
                // For carried over tasks, keep their previous state
                if (!isCarriedOver) {
                    gameState.taskStages[product.id] = 'backlog';
                    gameState.taskProgress[product.id] = 0;
                    
                    // Remove any existing defects for non-carried over tasks
                    delete gameState.taskDefects[product.id];
                }
            });
            
            // Sort products by carried over first, then by story points (descending)
            const sortedProducts = [...gameState.selectedProducts].sort((a, b) => {
                const aIsCarried = carriedOverIds.includes(a.id);
                const bIsCarried = carriedOverIds.includes(b.id);
                
                // First sort by carried over status
                if (aIsCarried && !bIsCarried) return -1;
                if (!aIsCarried && bIsCarried) return 1;
                
                // Then by story points
                return b.storyPoints - a.storyPoints;
            });
            
            let employeeCards = '';
            gameState.team.forEach(employee => {
                employeeCards += `
                    <div class="employee-card card">
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <div class="font-bold">${employee.name}</div>
                                <div class="text-sm text-gray-700 dark:text-gray-300">${employee.level} ${employee.type}</div>
                            </div>
                            <div class="text-xl text-primary">
                                <i class="${employee.icon}"></i>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="flex justify-between text-sm mb-1">
                                <span>Capacity:</span>
                                <span class="employee-capacity" data-id="${employee.id}">${employee.remainingCapacity}/${employee.capacity}</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                <div class="employee-capacity-bar bg-primary rounded-full h-2" data-id="${employee.id}" style="width: 100%"></div>
                            </div>
                        </div>
                        <div class="mb-3">
                            <div class="text-sm mb-1">Skills:</div>
                            <div class="flex flex-wrap gap-1">
                                ${employee.skills.map(skill => getSkillBadgeHtml(skill)).join('')}
                            </div>
                        </div>
                        <div>
                            <h5 class="text-sm font-semibold mb-2">Assigned Tasks:</h5>
                            <div class="employee-tasks min-h-[40px]" data-id="${employee.id}">
                                <p class="text-gray-700 dark:text-gray-300 text-center text-xs italic">No tasks assigned yet</p>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            let productCards = '';
            sortedProducts.forEach(product => {
                const skillBadges = product.skills.map(skill => getSkillBadgeHtml(skill)).join(' ');
                const isCarriedOver = carriedOverIds.includes(product.id);
                const pointsToShow = isCarriedOver ? 
                    gameState.carriedOverTasks.find(t => t.id === product.id).remainingPoints : 
                    product.storyPoints;
                const reworkCount = gameState.reworkCount[product.id] || 0;
                
                productCards += `
                    <div class="product-card card ${isCarriedOver ? 'border-orange-300 dark:border-orange-700' : ''} ${reworkCount > 0 ? 'border-rose-300 dark:border-rose-700' : ''}" data-product-id="${product.id}">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <h4 class="font-bold">${product.name}</h4>
                                <div class="mt-1 flex flex-wrap gap-1">
                                    ${isCarriedOver ? '<span class="carried-over-badge">Carried Over</span>' : ''}
                                    ${reworkCount > 0 ? `<span class="rework-badge">Reworked ${reworkCount}x</span>` : ''}
                                </div>
                            </div>
                            <div class="flex items-center">
                                <div class="product-progress text-xs mr-2" data-id="${product.id}">0/${pointsToShow}</div>
                                <div class="text-white bg-primary rounded-full w-8 h-8 flex items-center justify-center font-bold">
                                    ${pointsToShow}
                                </div>
                            </div>
                        </div>
                        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">${product.description}</p>
                        <div class="mb-3 space-x-1">
                            ${skillBadges}
                        </div>
                        <div class="mb-3">
                            <div class="flex justify-between text-sm mb-1">
                                <span>Completion:</span>
                                <span class="product-percent" data-id="${product.id}">0%</span>
                            </div>
                            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                <div class="product-progress-bar bg-primary rounded-full h-2" data-id="${product.id}" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="mb-3 product-assignments" data-id="${product.id}">
                            <p class="text-gray-700 dark:text-gray-300 text-center text-xs italic">No assignments yet</p>
                        </div>
                        <div class="grid grid-cols-1 gap-2">
                            <div class="flex gap-2">
                                <select 
                                    id="assign-${product.id}" 
                                    class="assign-product-employee block w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base"
                                    data-id="${product.id}"
                                >
                                    <option value="">-- Select Employee --</option>
                                    ${gameState.team.map(employee => {
                                        const canHandle = product.skills.some(skill => employee.skills.includes(skill));
                                        const hasCapacity = employee.remainingCapacity > 0;
                                        return `<option value="${employee.id}" ${!canHandle || !hasCapacity ? 'disabled' : ''}>${employee.name} (${employee.remainingCapacity} pts) ${!canHandle ? '(Missing skills)' : !hasCapacity ? '(No capacity)' : ''}</option>`;
                                    }).join('')}
                                </select>
                            </div>
                            <div class="flex gap-2">
                                <div class="relative flex-grow">
                                    <input 
                                        type="number" 
                                        id="points-${product.id}" 
                                        class="assign-product-points block w-full p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-700 text-base" 
                                        placeholder="Points to assign"
                                        min="1" 
                                        max="${pointsToShow}" 
                                        value="${Math.min(pointsToShow, gameState.team[0]?.remainingCapacity || 0)}"
                                        data-id="${product.id}"
                                    />
                                </div>
                                <button 
                                    class="assign-product btn-small btn-primary"
                                    data-id="${product.id}"
                                >
                                    Assign
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Assign Tasks</h2>
                            <p class="text-gray-700 dark:text-gray-300">Match products to team members based on skills and capacity</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-semibold">
                                Story Points: <span id="assigned-points">0</span>/<span id="total-points">0</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="grid md:grid-cols-2 gap-6 mb-8">
                        <div>
                            <h3 class="section-title mb-4">Team Members</h3>
                            <div class="space-y-4 employee-list">
                                ${employeeCards}
                            </div>
                        </div>
                        <div>
                            <h3 class="section-title mb-4">Products to Assign</h3>
                            <div class="space-y-4 product-list">
                                ${productCards}
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="back-to-backlog" class="btn btn-secondary">
                            Back to Backlog
                        </button>
                        <button id="continue-to-strategy" class="btn btn-primary opacity-50 cursor-not-allowed">
                            Continue to Sprint Planning
                        </button>
                    </div>
                </div>
            `;
            
            // Calculate total story points
            let totalPoints = 0;
            gameState.selectedProducts.forEach(product => {
                const isCarriedOver = carriedOverIds.includes(product.id);
                if (isCarriedOver) {
                    totalPoints += gameState.carriedOverTasks.find(t => t.id === product.id).remainingPoints;
                } else {
                    totalPoints += product.storyPoints;
                }
            });
            
            document.getElementById('total-points').textContent = totalPoints;
            
            // Add event listeners for employee selection
            const employeeSelects = document.querySelectorAll('.assign-product-employee');
            employeeSelects.forEach(select => {
                select.addEventListener('change', () => {
                    const productId = parseInt(select.getAttribute('data-id'));
                    const employeeId = select.value;
                    
                    if (employeeId) {
                        const employee = gameState.team.find(e => e.id === employeeId);
                        const isCarriedOver = carriedOverIds.includes(productId);
                        let remainingProductPoints;
                        
                        if (isCarriedOver) {
                            const carriedTask = gameState.carriedOverTasks.find(t => t.id === productId);
                            remainingProductPoints = carriedTask.remainingPoints - getProductAssignedPoints(productId);
                        } else {
                            remainingProductPoints = getProductRemainingPoints(productId);
                        }
                        
                        // Update points input to suggest a value
                        const pointsInput = document.getElementById(`points-${productId}`);
                        if (pointsInput) {
                            const suggestedPoints = Math.min(employee.remainingCapacity, remainingProductPoints);
                            pointsInput.value = suggestedPoints;
                            pointsInput.max = remainingProductPoints;
                        }
                    }
                });
            });
            
            // Add event listeners for assign buttons
            const assignButtons = document.querySelectorAll('.assign-product');
            assignButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const productId = parseInt(button.getAttribute('data-id'));
                    const select = document.getElementById(`assign-${productId}`);
                    const pointsInput = document.getElementById(`points-${productId}`);
                    
                    if (select && pointsInput) {
                        const employeeId = select.value;
                        const points = parseInt(pointsInput.value);
                        
                        if (!employeeId) {
                            showNotification('Please select an employee', 'error');
                            return;
                        }
                        
                        if (!points || points <= 0) {
                            showNotification('Please enter a valid number of points', 'error');
                            return;
                        }
                        
                        assignProduct(productId, employeeId, points);
                    }
                });
            });
            
            document.getElementById('back-to-backlog').addEventListener('click', () => {
                renderPhase('backlogSelection');
            });
            
            document.getElementById('continue-to-strategy').addEventListener('click', () => {
                // Count total assigned story points
                gameState.assignedStoryPoints = Object.values(gameState.assignedTasks).flat().reduce((sum, assignment) => sum + assignment.storyPoints, 0);
                gameState.unassignedStoryPoints = totalPoints - gameState.assignedStoryPoints;
                
                // Check if all story points are assigned
                if (gameState.unassignedStoryPoints > 0) {
                    showNotification('Please assign all story points before continuing', 'error');
                    return;
                }
                
                if (gameState.assignedStoryPoints > 0) {
                    renderPhase('sprintStrategy');
                } else {
                    showNotification('Please assign at least one product to continue', 'error');
                }
            });
        }

        // Assign a product to an employee
        function assignProduct(productId, employeeId, assignedPoints) {
            // Find the product
            const product = gameState.selectedProducts.find(p => p.id === productId);
            const isCarriedOver = gameState.carriedOverTasks.some(t => t.id === productId);
            const productPoints = isCarriedOver ? 
                gameState.carriedOverTasks.find(t => t.id === productId).remainingPoints : 
                product.storyPoints;
            
            // If employeeId is empty, just update UI to show unassigned
            if (!employeeId) {
                updateAssignmentUI();
                return;
            }
            
            // Find the employee
            const employee = gameState.team.find(e => e.id === employeeId);
            
            // Check if employee has necessary skills
            const hasSkills = product.skills.some(skill => employee.skills.includes(skill));
            if (!hasSkills) {
                showNotification(`${employee.name} doesn't have the required skills for this product`, 'error');
                return;
            }
            
            // Check if employee has enough capacity
            if (employee.remainingCapacity < assignedPoints) {
                showNotification(`${employee.name} doesn't have enough capacity for this assignment`, 'error');
                return;
            }
            
            // Check if we're trying to assign more points than the product has
            const existingAssignedPoints = getProductAssignedPoints(productId);
            const remainingProductPoints = productPoints - existingAssignedPoints;
            
            if (assignedPoints > remainingProductPoints) {
                showNotification(`Cannot assign more than ${remainingProductPoints} remaining points to this product`, 'error');
                return;
            }
            
            // Check if this employee already has this product assigned
            const existingTaskIndex = gameState.assignedTasks[employeeId].findIndex(task => task.id === productId);
            
            if (existingTaskIndex !== -1) {
                // Update existing assignment
                const oldPoints = gameState.assignedTasks[employeeId][existingTaskIndex].storyPoints;
                gameState.assignedTasks[employeeId][existingTaskIndex].storyPoints = assignedPoints;
                employee.remainingCapacity += oldPoints - assignedPoints;
            } else {
                // Create new assignment
                gameState.assignedTasks[employeeId].push({
                    id: productId,
                    name: product.name,
                    storyPoints: assignedPoints,
                    isCarriedOver: isCarriedOver
                });
                
                // Update employee capacity
                employee.remainingCapacity -= assignedPoints;
            }
            
            // Update UI
            updateAssignmentUI();
            
            // Show success notification
            showNotification(`Assigned ${assignedPoints} points of "${product.name}" to ${employee.name}`, 'success');
        }

        // Update the task assignment UI
        function updateAssignmentUI() {
            const carriedOverIds = gameState.carriedOverTasks.map(task => task.id);
            
            // Update employee capacity and task list
            gameState.team.forEach(employee => {
                const capacityElem = document.querySelector(`.employee-capacity[data-id="${employee.id}"]`);
                const capacityBar = document.querySelector(`.employee-capacity-bar[data-id="${employee.id}"]`);
                const tasksContainer = document.querySelector(`.employee-tasks[data-id="${employee.id}"]`);
                
                if (capacityElem) {
                    capacityElem.textContent = `${employee.remainingCapacity}/${employee.capacity}`;
                }
                
                if (capacityBar) {
                    const capacityPercentage = (employee.remainingCapacity / employee.capacity) * 100;
                    capacityBar.style.width = `${capacityPercentage}%`;
                    
                    // Change color based on remaining capacity
                    if (capacityPercentage > 70) {
                        capacityBar.classList.remove('bg-yellow-500', 'bg-red-500');
                        capacityBar.classList.add('bg-primary');
                    } else if (capacityPercentage > 30) {
                        capacityBar.classList.remove('bg-primary', 'bg-red-500');
                        capacityBar.classList.add('bg-yellow-500');
                    } else {
                        capacityBar.classList.remove('bg-primary', 'bg-yellow-500');
                        capacityBar.classList.add('bg-red-500');
                    }
                }
                
                if (tasksContainer) {
                    const tasks = gameState.assignedTasks[employee.id] || [];
                    if (tasks.length === 0) {
                        tasksContainer.innerHTML = '<p class="text-gray-700 dark:text-gray-300 text-center text-xs italic">No tasks assigned yet</p>';
                    } else {
                        let tasksHtml = '';
                        tasks.forEach(task => {
                            const isCarriedOver = carriedOverIds.includes(task.id);
                            const reworkCount = gameState.reworkCount[task.id] || 0;
                            tasksHtml += `
                                <div class="bg-gray-100 dark:bg-gray-700 rounded p-2 mb-2 text-sm flex justify-between items-center 
                                    ${isCarriedOver ? 'border-l-4 border-orange-400 dark:border-orange-600' : ''}
                                    ${reworkCount > 0 ? 'border-l-4 border-rose-400 dark:border-rose-600' : ''}"
                                >
                                    <span>${task.name} 
                                        ${isCarriedOver ? '<span class="text-xs text-orange-600 dark:text-orange-400">(carried over)</span>' : ''}
                                        ${reworkCount > 0 ? `<span class="text-xs text-rose-600 dark:text-rose-400">(reworked ${reworkCount}x)</span>` : ''}
                                    </span>
                                    <span class="font-semibold">${task.storyPoints} pts</span>
                                </div>
                            `;
                        });
                        tasksContainer.innerHTML = tasksHtml;
                    }
                }
            });
            
            // Update product assignment display
            gameState.selectedProducts.forEach(product => {
                const productAssignmentsContainer = document.querySelector(`.product-assignments[data-id="${product.id}"]`);
                const progressElem = document.querySelector(`.product-progress[data-id="${product.id}"]`);
                const progressBar = document.querySelector(`.product-progress-bar[data-id="${product.id}"]`);
                const percentElem = document.querySelector(`.product-percent[data-id="${product.id}"]`);
                
                const isCarriedOver = carriedOverIds.includes(product.id);
                const totalProductPoints = isCarriedOver ? 
                    gameState.carriedOverTasks.find(t => t.id === product.id).remainingPoints : 
                    product.storyPoints;
                
                // Get all assignments for this product
                const productAssignments = [];
                for (const empId in gameState.assignedTasks) {
                    const tasks = gameState.assignedTasks[empId].filter(t => t.id === product.id);
                    tasks.forEach(task => {
                        const employee = gameState.team.find(e => e.id === empId);
                        productAssignments.push({
                            employee: employee,
                            points: task.storyPoints
                        });
                    });
                }
                
                // Calculate total assigned points
                const totalAssignedPoints = productAssignments.reduce((sum, assignment) => sum + assignment.points, 0);
                const percentComplete = Math.round((totalAssignedPoints / totalProductPoints) * 100);
                
                // Update progress elements
                if (progressElem) {
                    progressElem.textContent = `${totalAssignedPoints}/${totalProductPoints}`;
                }
                
                if (progressBar) {
                    progressBar.style.width = `${percentComplete}%`;
                    
                    // Change color based on completion
                    if (percentComplete === 100) {
                        progressBar.classList.remove('bg-yellow-500', 'bg-primary');
                        progressBar.classList.add('bg-green-500');
                    } else if (percentComplete > 0) {
                        progressBar.classList.remove('bg-green-500');
                        progressBar.classList.add('bg-primary');
                    }
                }
                
                if (percentElem) {
                    percentElem.textContent = `${percentComplete}%`;
                }
                
                // Update assignments display
                if (productAssignmentsContainer) {
                    if (productAssignments.length === 0) {
                        productAssignmentsContainer.innerHTML = '<p class="text-gray-700 dark:text-gray-300 text-center text-xs italic">No assignments yet</p>';
                    } else {
                        let assignmentsHtml = '<div class="space-y-1">';
                        productAssignments.forEach(assignment => {
                            assignmentsHtml += `
                                <div class="bg-gray-100 dark:bg-gray-700 rounded px-2 py-1 text-xs flex justify-between items-center">
                                    <span>${assignment.employee.name}</span>
                                    <div class="flex items-center">
                                        <span class="font-semibold">${assignment.points} pts</span>
                                        <button class="remove-assignment ml-2 text-red-500 hover:text-red-700" 
                                            data-product-id="${product.id}" 
                                            data-employee-id="${assignment.employee.id}">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                </div>
                            `;
                        });
                        assignmentsHtml += '</div>';
                        productAssignmentsContainer.innerHTML = assignmentsHtml;
                        
                        // Add event listeners for remove buttons
                        const removeButtons = productAssignmentsContainer.querySelectorAll('.remove-assignment');
                        removeButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                const productId = parseInt(button.getAttribute('data-product-id'));
                                const employeeId = button.getAttribute('data-employee-id');
                                removeAssignment(productId, employeeId);
                            });
                        });
                    }
                }
                
                // Update dropdowns based on remaining points and capacities
                const select = document.getElementById(`assign-${product.id}`);
                if (select) {
                    const remainingProductPoints = totalProductPoints - totalAssignedPoints;
                    if (remainingProductPoints === 0) {
                        // Product fully assigned, disable dropdown
                        select.disabled = true;
                        const optionElements = select.querySelectorAll('option');
                        optionElements.forEach(option => {
                            option.disabled = true;
                        });
                    } else {
                        // Update employee options based on remaining capacity
                        select.disabled = false;
                        const optionElements = select.querySelectorAll('option');
                        optionElements.forEach(option => {
                            if (option.value) {
                                const employee = gameState.team.find(e => e.id === option.value);
                                const canHandle = product.skills.some(skill => employee.skills.includes(skill));
                                const hasCapacity = employee.remainingCapacity > 0;
                                
                                option.disabled = !canHandle || !hasCapacity;
                                option.textContent = `${employee.name} (${employee.remainingCapacity} pts) ${!canHandle ? '(Missing skills)' : !hasCapacity ? '(No capacity)' : ''}`;
                            } else {
                                option.disabled = false;
                            }
                        });
                    }
                }
                
                // Update points input based on remaining product points
                const pointsInput = document.getElementById(`points-${product.id}`);
                if (pointsInput) {
                    const remainingProductPoints = totalProductPoints - totalAssignedPoints;
                    pointsInput.max = remainingProductPoints;
                    
                    // If selected employee, limit to their capacity
                    const select = document.getElementById(`assign-${product.id}`);
                    if (select && select.value) {
                        const employee = gameState.team.find(e => e.id === select.value);
                        const maxPoints = Math.min(employee.remainingCapacity, remainingProductPoints);
                        pointsInput.value = Math.min(parseInt(pointsInput.value) || 0, maxPoints);
                    } else {
                        pointsInput.value = Math.min(parseInt(pointsInput.value) || 0, remainingProductPoints);
                    }
                    
                    // Disable if no points left to assign
                    pointsInput.disabled = remainingProductPoints === 0;
                }
                
                // Update assign button based on remaining points
                const assignButton = document.querySelector(`.assign-product[data-id="${product.id}"]`);
                if (assignButton) {
                    const remainingProductPoints = totalProductPoints - totalAssignedPoints;
                    assignButton.disabled = remainingProductPoints === 0;
                    if (remainingProductPoints === 0) {
                        assignButton.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        assignButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    }
                }
            });
            
            // Calculate and update assigned story points
            let assignedPoints = 0;
            for (const empId in gameState.assignedTasks) {
                assignedPoints += gameState.assignedTasks[empId].reduce((sum, task) => sum + task.storyPoints, 0);
            }
            
            const assignedPointsElem = document.getElementById('assigned-points');
            if (assignedPointsElem) {
                assignedPointsElem.textContent = assignedPoints;
            }
            
            // Update continue button state
            const continueButton = document.getElementById('continue-to-strategy');
            if (continueButton) {
                if (assignedPoints > 0) {
                    continueButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    continueButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // Remove an assignment
        function removeAssignment(productId, employeeId) {
            const employee = gameState.team.find(e => e.id === employeeId);
            const taskIndex = gameState.assignedTasks[employeeId].findIndex(t => t.id === productId);
            
            if (taskIndex !== -1) {
                // Return capacity to employee
                const points = gameState.assignedTasks[employeeId][taskIndex].storyPoints;
                employee.remainingCapacity += points;
                
                // Remove task
                gameState.assignedTasks[employeeId].splice(taskIndex, 1);
                
                // Update UI
                updateAssignmentUI();
                showNotification(`Removed assignment from ${employee.name}`, 'info');
            }
        }

        // Render Sprint Strategy Phase
        function renderSprintStrategyPhase(container) {
            // Reset selected strategies
            gameState.selectedStrategies = [];
            
            let strategyCards = '';
            teamStrategies.forEach(strategy => {
                strategyCards += `
                    <div class="strategy-card card card-hover">
                        <h4 class="font-bold mb-2">${strategy.name}</h4>
                        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">${strategy.description}</p>
                        <div class="bg-gray-50 dark:bg-gray-800 p-2 rounded mb-3 text-sm">
                            <span class="font-semibold">Effect:</span> ${strategy.effect}
                        </div>
                        <button 
                            class="select-strategy w-full py-2 px-4 rounded-md bg-gray-100 dark:bg-gray-700 hover:bg-primary hover:text-white transition-colors"
                            data-id="${strategy.id}"
                        >
                            Select
                        </button>
                    </div>
                `;
            });
            
            // Show carried over tasks section if any exist
            let carriedOverMessage = '';
            if (gameState.carriedOverTasks.length > 0) {
                carriedOverMessage = `
                    <div class="bg-amber-50 dark:bg-amber-900/20 p-3 rounded-lg mb-4">
                        <div class="flex items-start">
                            <div class="text-amber-700 dark:text-amber-300 mr-3 mt-1">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <div>
                                <h4 class="font-semibold text-amber-700 dark:text-amber-300 mb-1">Carried Over Tasks</h4>
                                <p class="text-amber-800 dark:text-amber-200 text-sm">
                                    You have ${gameState.carriedOverTasks.length} incomplete task(s) from the previous sprint. 
                                    These tasks must be completed before the end of this sprint.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Show reworked tasks section if any exist
            let reworkMessage = '';
            let hasReworked = false;
            Object.keys(gameState.reworkCount).forEach(id => {
                if (gameState.reworkCount[id] > 0) {
                    hasReworked = true;
                }
            });
            
            if (hasReworked) {
                reworkMessage = `
                    <div class="bg-rose-50 dark:bg-rose-900/20 p-3 rounded-lg mb-4">
                        <div class="flex items-start">
                            <div class="text-rose-700 dark:text-rose-300 mr-3 mt-1">
                                <i class="fas fa-sync-alt"></i>
                            </div>
                            <div>
                                <h4 class="font-semibold text-rose-700 dark:text-rose-300 mb-1">Reworked Tasks</h4>
                                <p class="text-rose-800 dark:text-rose-200 text-sm">
                                    Some tasks have been reworked because they didn't meet the Definition of Done.
                                    Each rework increases the chance of meeting the requirements.
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Sprint Planning</h2>
                            <p class="text-gray-700 dark:text-gray-300">Choose strategies for Sprint ${gameState.currentSprint + 1}</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-semibold">
                                Selected: <span id="selected-strategy-count">0</span>/2 strategies
                            </div>
                        </div>
                    </div>
                    
                    ${carriedOverMessage}
                    ${reworkMessage}
                    
                    <div class="panel-blue mb-6">
                        <h3 class="font-semibold text-blue-800 dark:text-blue-200 mb-2">Sprint ${gameState.currentSprint + 1} Overview</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-blue-800 dark:text-blue-200">
                            <div>
                                <span class="font-medium">Team Size:</span> ${gameState.team.length} members
                            </div>
                            <div>
                                <span class="font-medium">Assigned Points:</span> ${gameState.assignedStoryPoints}
                            </div>
                            <div>
                                <span class="font-medium">Unassigned Points:</span> ${gameState.unassignedStoryPoints}
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="section-title">Selected Strategies</h3>
                        <div id="selected-strategies" class="panel min-h-[100px]">
                            <p class="text-gray-700 dark:text-gray-300 text-center italic">Your selected strategies will appear here (max 2)</p>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <h3 class="section-title mb-4">Available Strategies</h3>
                        <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                            ${strategyCards}
                        </div>
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="back-to-tasks" class="btn btn-secondary">
                            Back to Task Assignment
                        </button>
                        <button id="start-sprint" class="btn btn-primary">
                            Start Sprint!
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            const strategyButtons = document.querySelectorAll('.select-strategy');
            strategyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const strategyId = button.getAttribute('data-id');
                    toggleStrategySelection(strategyId);
                });
            });
            
            document.getElementById('back-to-tasks').addEventListener('click', () => {
                renderPhase('taskAssignment');
            });
            
            document.getElementById('start-sprint').addEventListener('click', () => {
                // Prepare events for this sprint
                prepareSprintEvents();
                
                // Start the sprint
                gameState.sprintDay = 1;
                gameState.lastStageUpdateDay = 1;
                renderPhase('sprint');
            });
        }

        // Toggle strategy selection
        function toggleStrategySelection(strategyId) {
            const selectedIndex = gameState.selectedStrategies.findIndex(s => s === strategyId);
            const strategy = teamStrategies.find(s => s.id === strategyId);
            
            if (selectedIndex === -1) {
                // Add strategy if we have less than 2
                if (gameState.selectedStrategies.length < 2) {
                    gameState.selectedStrategies.push(strategyId);
                } else {
                    showNotification('You can select a maximum of 2 strategies', 'error');
                    return;
                }
            } else {
                // Remove strategy
                gameState.selectedStrategies.splice(selectedIndex, 1);
            }
            
            updateSelectedStrategies();
        }

        // Update display of selected strategies
        function updateSelectedStrategies() {
            const strategiesContainer = document.getElementById('selected-strategies');
            const countDisplay = document.getElementById('selected-strategy-count');
            
            if (countDisplay) {
                countDisplay.textContent = gameState.selectedStrategies.length;
            }
            
            if (strategiesContainer) {
                if (gameState.selectedStrategies.length === 0) {
                    strategiesContainer.innerHTML = '<p class="text-gray-700 dark:text-gray-300 text-center italic">Your selected strategies will appear here (max 2)</p>';
                } else {
                    let strategiesHtml = '<div class="space-y-3">';
                    
                    gameState.selectedStrategies.forEach(strategyId => {
                        const strategy = teamStrategies.find(s => s.id === strategyId);
                        strategiesHtml += `
                            <div class="card flex justify-between items-center">
                                <div>
                                    <h4 class="font-semibold">${strategy.name}</h4>
                                    <p class="text-sm text-gray-700 dark:text-gray-300">${strategy.effect}</p>
                                </div>
                                <button class="remove-strategy text-red-500 hover:text-red-700 dark:hover:text-red-400 p-1" data-id="${strategy.id}">
                                    <i class="fas fa-times"></i>
                                </button>
                            </div>
                        `;
                    });
                    
                    strategiesHtml += '</div>';
                    strategiesContainer.innerHTML = strategiesHtml;
                    
                    // Add event listeners for remove buttons
                    const removeButtons = document.querySelectorAll('.remove-strategy');
                    removeButtons.forEach(button => {
                        button.addEventListener('click', () => {
                            const strategyId = button.getAttribute('data-id');
                            const selectedIndex = gameState.selectedStrategies.findIndex(s => s === strategyId);
                            if (selectedIndex !== -1) {
                                gameState.selectedStrategies.splice(selectedIndex, 1);
                                updateSelectedStrategies();
                            }
                        });
                    });
                }
            }
            
            // Update select buttons
            const selectButtons = document.querySelectorAll('.select-strategy');
            selectButtons.forEach(button => {
                const strategyId = button.getAttribute('data-id');
                const isSelected = gameState.selectedStrategies.includes(strategyId);
                
                if (isSelected) {
                    button.textContent = 'Selected';
                    button.classList.add('bg-primary', 'text-white');
                    button.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'hover:bg-primary');
                } else {
                    button.textContent = 'Select';
                    button.classList.remove('bg-primary', 'text-white');
                    button.classList.add('bg-gray-100', 'dark:bg-gray-700', 'hover:bg-primary', 'hover:text-white');
                }
            });
        }

        // Prepare random events for the sprint
        function prepareSprintEvents() {
            // Reset events
            gameState.events = [];
            gameState.currentEvent = null;
            
            // Shuffle events and pick 3 random ones for this sprint
            const shuffledEvents = shuffleArray([...sprintEvents]);
            gameState.events = shuffledEvents.slice(0, 3);
            
            // Assign random days for events (days 2-4)
            gameState.events.forEach(event => {
                event.day = Math.floor(Math.random() * 3) + 2; // Days 2, 3, or 4
            });
            
            // Sort events by day
            gameState.events.sort((a, b) => a.day - b.day);
        }

        // Render Sprint Phase
        function renderSprintPhase(container) {
            // Check if there's an event for this day
            const todayEvent = gameState.events.find(event => event.day === gameState.sprintDay);
            if (todayEvent && !gameState.currentEvent) {
                gameState.currentEvent = todayEvent;
            }
            
            // Calculate progress
            const progressPercentage = (gameState.sprintDay / gameState.sprintLength) * 100;
            
            // Process task movement between stages
            if (gameState.sprintDay > gameState.lastStageUpdateDay) {
                updateTaskStages();
                gameState.lastStageUpdateDay = gameState.sprintDay;
            }
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Sprint ${gameState.currentSprint + 1} in Progress</h2>
                            <p class="text-gray-700 dark:text-gray-300">Day ${gameState.sprintDay} of ${gameState.sprintLength}</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue text-blue-800 dark:text-blue-200">
                            <div class="flex items-center">
                                <i class="fas fa-users mr-2"></i>
                                <span>Team Morale: <span id="team-morale">${gameState.teamMorale}%</span></span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-6">
                        <div class="flex justify-between text-sm mb-1">
                            <span>Sprint Progress:</span>
                            <span>Day ${gameState.sprintDay}/${gameState.sprintLength}</span>
                        </div>
                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                            <div class="progress-bar bg-primary rounded-full h-4" style="width: ${progressPercentage}%"></div>
                        </div>
                    </div>
                    
                    ${gameState.currentEvent ? 
                        renderEventContent(gameState.currentEvent) : 
                        renderKanbanBoard()
                    }
                    
                    <div class="panel mb-6">
                        <h3 class="font-semibold mb-2">Active Team Strategies</h3>
                        ${gameState.selectedStrategies.length > 0 ? 
                            `<div class="flex flex-wrap gap-2">
                                ${gameState.selectedStrategies.map(strategyId => {
                                    const strategy = teamStrategies.find(s => s.id === strategyId);
                                    return `<span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">${strategy.name}</span>`;
                                }).join('')}
                            </div>` : 
                            '<p class="text-gray-700 dark:text-gray-300 italic">No strategies selected for this sprint</p>'
                        }
                    </div>
                    
                    <div id="sprint-actions" class="flex justify-end mt-8">
                        ${gameState.currentEvent ? 
                            '' : 
                            `<button id="next-day" class="btn btn-primary">
                                ${gameState.sprintDay === gameState.sprintLength ? 'End Sprint' : 'Next Day'}
                            </button>`
                        }
                    </div>
                </div>
            `;
            
            // Add event listeners
            if (!gameState.currentEvent) {
                document.getElementById('next-day').addEventListener('click', () => {
                    advanceSprintDay();
                });
                
                // Add drag and drop for kanban items
                setupKanbanDragDrop();
                
                // Add defect resolving functionality
                setupDefectResolving();
                
                // Add rework task functionality
                setupReworkTasks();
            }
        }

        // Setup rework task functionality
        function setupReworkTasks() {
            const reworkButtons = document.querySelectorAll('.rework-task');
            
            reworkButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const productId = parseInt(button.getAttribute('data-product-id'));
                    
                    if (reworkTask(productId)) {
                        showNotification('Task moved back to In Progress for rework', 'info');
                        renderKanbanBoard();
                        setupKanbanDragDrop();
                        setupDefectResolving();
                        setupReworkTasks();
                    }
                });
            });
        }

        // Setup drag and drop for kanban items
        function setupKanbanDragDrop() {
            const kanbanItems = document.querySelectorAll('.kanban-item');
            const dropZones = document.querySelectorAll('.kanban-column-content');
            
            kanbanItems.forEach(item => {
                item.setAttribute('draggable', true);
                
                item.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', item.getAttribute('data-id'));
                    item.classList.add('opacity-50');
                });
                
                item.addEventListener('dragend', () => {
                    item.classList.remove('opacity-50');
                });
            });
            
            dropZones.forEach(zone => {
                zone.addEventListener('dragover', e => {
                    e.preventDefault();
                    zone.classList.add('bg-gray-100', 'dark:bg-gray-700/50');
                });
                
                zone.addEventListener('dragleave', () => {
                    zone.classList.remove('bg-gray-100', 'dark:bg-gray-700/50');
                });
                
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('bg-gray-100', 'dark:bg-gray-700/50');
                    
                    const productId = parseInt(e.dataTransfer.getData('text/plain'));
                    const targetStage = zone.getAttribute('data-stage');
                    const currentStage = gameState.taskStages[productId];
                    
                    // Check if move is valid based on workflow
                    if (isValidStageMove(currentStage, targetStage)) {
                        // Additional validation for moving from Testing to Done
                        if (currentStage === 'testing' && targetStage === 'done') {
                            // Check if the task meets the Definition of Done
                            if (!meetsDefinitionOfDone(productId)) {
                                showNotification('This task does not meet the Definition of Done! Use the "Move to In Progress" button to rework it.', 'error');
                                return;
                            }
                        }
                        
                        // Additional validation for moving to Testing
                        if (currentStage === 'inProgress' && targetStage === 'testing') {
                            // Only allow if progress is 100%
                            if ((gameState.taskProgress[productId] || 0) < 100) {
                                showNotification('This task is not fully implemented yet! Wait until progress reaches 100%.', 'error');
                                return;
                            }
                            
                            // Generate defects when moving from In Progress to Testing
                            if (!gameState.taskDefects[productId]) {
                                gameState.taskDefects[productId] = generateDefects(productId);
                            }
                        }
                        
                        // Track stage change
                        gameState.taskStages[productId] = targetStage;
                        
                        // If moving to 'inProgress', generate defects
                        if (targetStage === 'inProgress' && !gameState.taskDefects[productId]) {
                            gameState.taskDefects[productId] = generateDefects(productId);
                            gameState.taskProgress[productId] = 0;
                        }
                        
                        // Reset progress for new stage
                        if (targetStage !== currentStage) {
                            gameState.taskProgress[productId] = 0;
                        }
                        
                        // Update the kanban board
                        renderKanbanBoard();
                        setupKanbanDragDrop();
                        setupDefectResolving();
                        setupReworkTasks();
                    } else {
                        showNotification('Invalid move! Please follow the workflow: Backlog  In Progress  Testing  Done', 'error');
                    }
                });
            });
        }

        // Check if a stage move is valid (follows the workflow)
        function isValidStageMove(currentStage, targetStage) {
            // Define the valid progression
            const workflow = {
                'backlog': ['inProgress'],
                'inProgress': ['testing'],
                'testing': ['done', 'inProgress'], // Allow testing -> inProgress for rework
                'done': []
            };
            
            return workflow[currentStage].includes(targetStage);
        }

        // Setup defect resolving functionality
        function setupDefectResolving() {
            const resolveButtons = document.querySelectorAll('.resolve-defect');
            
            resolveButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const productId = parseInt(button.getAttribute('data-product-id'));
                    const defectIndex = parseInt(button.getAttribute('data-index'));
                    
                    // Remove the defect
                    if (gameState.taskDefects[productId] && gameState.taskDefects[productId][defectIndex]) {
                        gameState.taskDefects[productId].splice(defectIndex, 1);
                        
                        // Show notification
                        showNotification('Defect resolved!', 'success');
                        
                        // Update the kanban board
                        renderKanbanBoard();
                        setupKanbanDragDrop();
                        setupDefectResolving();
                        setupReworkTasks();
                    }
                });
            });
        }

        // Update task stages based on progress
        function updateTaskStages() {
            // Handle progress for tasks in each stage
            Object.keys(gameState.taskStages).forEach(productIdStr => {
                const productId = parseInt(productIdStr);
                const stage = gameState.taskStages[productId];
                
                // Initialize progress if not set
                if (gameState.taskProgress[productId] === undefined) {
                    gameState.taskProgress[productId] = 0;
                }
                
                // For tasks in progress, advance them based on team capacity and defects
                if (stage === 'inProgress') {
                    // Calculate base progress increment
                    let progressIncrement = 10; // Base progress per day
                    
                    // Apply efficiency multiplier from definition of done
                    progressIncrement *= gameState.sprintEfficiency;
                    
                    // Check for high severity defects
                    const defects = gameState.taskDefects[productId] || [];
                    const highDefects = defects.filter(d => d.severity === 'high').length;
                    
                    // High defects slow down progress
                    if (highDefects > 0) {
                        progressIncrement = progressIncrement / (1 + highDefects);
                    }
                    
                    // Reworked tasks progress faster
                    const reworkCount = gameState.reworkCount[productId] || 0;
                    if (reworkCount > 0) {
                        // Each rework gives a 20% boost to progress rate
                        progressIncrement *= (1 + (reworkCount * 0.2));
                    }
                    
                    // Update progress
                    gameState.taskProgress[productId] += progressIncrement;
                    
                    // If reached 100%, automatically move to testing
                    if (gameState.taskProgress[productId] >= 100) {
                        gameState.taskStages[productId] = 'testing';
                        gameState.taskProgress[productId] = 0;
                        
                        // Generate defects when moving to testing
                        if (!gameState.taskDefects[productId]) {
                            gameState.taskDefects[productId] = generateDefects(productId);
                        }
                    }
                }
                
                // For tasks in testing, advance them based on defects
                else if (stage === 'testing') {
                    // Calculate base progress increment
                    let progressIncrement = 20; // Testing is usually faster than development
                    
                    // Apply efficiency multiplier
                    progressIncrement *= gameState.sprintEfficiency;
                    
                    // Check for defects
                    const defects = gameState.taskDefects[productId] || [];
                    const mediumDefects = defects.filter(d => d.severity === 'medium').length;
                    const lowDefects = defects.filter(d => d.severity === 'low').length;
                    
                    // Medium and low defects slow down testing
                    progressIncrement = progressIncrement / (1 + (mediumDefects * 0.5) + (lowDefects * 0.2));
                    
                    // Update progress
                    gameState.taskProgress[productId] += progressIncrement;
                    
                    // If reached 100%, check if it meets definition of done
                    if (gameState.taskProgress[productId] >= 100) {
                        // Keep progress at 100% but don't automatically move to done
                        gameState.taskProgress[productId] = 100;
                    }
                }
            });
        }

        // Render the Kanban board
        function renderKanbanBoard() {
            // Count items in each stage
            const counts = {
                backlog: Object.entries(gameState.taskStages).filter(([_, stage]) => stage === 'backlog').length,
                inProgress: Object.entries(gameState.taskStages).filter(([_, stage]) => stage === 'inProgress').length,
                testing: Object.entries(gameState.taskStages).filter(([_, stage]) => stage === 'testing').length,
                done: Object.entries(gameState.taskStages).filter(([_, stage]) => stage === 'done').length
            };
            
            const kanbanHtml = `
                <div class="mb-6">
                    <h3 class="font-bold text-lg mb-4">Sprint Kanban Board</h3>
                    <div class="kanban-board overflow-x-auto pb-2">
                        <div class="min-w-full grid grid-cols-4 gap-4">
                            <!-- Backlog Column -->
                            <div class="kanban-column">
                                <div class="kanban-column-header">
                                    <span>Backlog</span>
                                    <span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${counts.backlog}</span>
                                </div>
                                <div class="kanban-column-content min-h-[200px]" data-stage="backlog">
                                    ${renderKanbanItems('backlog')}
                                </div>
                            </div>
                            
                            <!-- In Progress Column -->
                            <div class="kanban-column">
                                <div class="kanban-column-header">
                                    <span>In Progress</span>
                                    <span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${counts.inProgress}</span>
                                </div>
                                <div class="kanban-column-content min-h-[200px]" data-stage="inProgress">
                                    ${renderKanbanItems('inProgress')}
                                </div>
                            </div>
                            
                            <!-- Testing Column -->
                            <div class="kanban-column">
                                <div class="kanban-column-header">
                                    <span>Testing</span>
                                    <span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${counts.testing}</span>
                                </div>
                                <div class="kanban-column-content min-h-[200px]" data-stage="testing">
                                    ${renderKanbanItems('testing')}
                                </div>
                            </div>
                            
                            <!-- Done Column -->
                            <div class="kanban-column">
                                <div class="kanban-column-header">
                                    <span>Done</span>
                                    <span class="bg-gray-200 dark:bg-gray-700 text-xs px-2 py-1 rounded-full">${counts.done}</span>
                                </div>
                                <div class="kanban-column-content min-h-[200px]" data-stage="done">
                                    ${renderKanbanItems('done')}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mb-6">
                    <h3 class="font-bold text-lg mb-4">Sprint Activities</h3>
                    ${renderRandomDevelopmentDialogue()}
                </div>
            `;
            
            // Check if we're in the sprint view without an event
            const sprintContent = document.getElementById('sprint-content');
            if (sprintContent && !gameState.currentEvent) {
                sprintContent.innerHTML = kanbanHtml;
            }
            
            return kanbanHtml;
        }

        // Render the Kanban items for a specific stage
        function renderKanbanItems(stage) {
            let itemsHtml = '';
            
            // Find products in this stage
            const productsInStage = gameState.selectedProducts.filter(product => 
                gameState.taskStages[product.id] === stage
            );
            
            if (productsInStage.length === 0) {
                itemsHtml = `<div class="text-gray-500 dark:text-gray-400 text-xs text-center italic mt-2">No items</div>`;
            } else {
                productsInStage.forEach(product => {
                    const defects = gameState.taskDefects[product.id] || [];
                    const highDefects = defects.filter(d => d.severity === 'high').length;
                    const mediumDefects = defects.filter(d => d.severity === 'medium').length;
                    const lowDefects = defects.filter(d => d.severity === 'low').length;
                    
                    // Calculate progress for this item
                    const progress = gameState.taskProgress[product.id] || 0;
                    
                    // Check if item meets definition of done (for testing stage)
                    const meetsDoD = meetsDefinitionOfDone(product.id);
                    const canMoveToDone = stage === 'testing' && progress >= 100 && meetsDoD;
                    
                    // Flags for warning indicators
                    const hasBlockingDefects = stage === 'testing' && !meetsDoD;
                    
                    // Check if task is carried over
                    const isCarriedOver = gameState.carriedOverTasks.some(t => t.id === product.id);
                    
                    // Check if task has been reworked
                    const reworkCount = gameState.reworkCount[product.id] || 0;
                    
                    // Add rework button in testing stage if task doesn't meet DoD
                    const reworkButton = stage === 'testing' && !meetsDoD ? 
                        `<button class="rework-task mt-2 w-full py-1 px-3 bg-rose-100 text-rose-800 dark:bg-rose-900/30 dark:text-rose-300 rounded text-xs font-medium hover:bg-rose-200 dark:hover:bg-rose-900/50" data-product-id="${product.id}">
                            <i class="fas fa-sync-alt mr-1"></i> Move to In Progress
                        </button>` : '';
                    
                    itemsHtml += `
                        <div class="kanban-item ${hasBlockingDefects ? 'border-red-300 dark:border-red-700' : ''} ${isCarriedOver ? 'border-orange-300 dark:border-orange-700' : ''} ${reworkCount > 0 ? 'border-rose-300 dark:border-rose-700' : ''}" data-id="${product.id}">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold text-sm">
                                    ${product.name}
                                    <div class="mt-1 flex flex-wrap gap-1">
                                        ${isCarriedOver ? '<span class="carried-over-badge">Carried Over</span>' : ''}
                                        ${reworkCount > 0 ? `<span class="rework-badge">Reworked ${reworkCount}x</span>` : ''}
                                    </div>
                                </h4>
                                <div class="text-xs font-semibold bg-primary/10 text-primary px-2 py-1 rounded">
                                    ${isCarriedOver ? 
                                        gameState.carriedOverTasks.find(t => t.id === product.id).remainingPoints : 
                                        product.storyPoints} pts
                                </div>
                            </div>
                            
                            ${progress > 0 ? `
                                <div class="mb-2">
                                    <div class="flex justify-between text-xs mb-1">
                                        <span>${Math.min(100, Math.round(progress))}%</span>
                                    </div>
                                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-1.5">
                                        <div class="bg-primary rounded-full h-1.5" style="width: ${Math.min(100, Math.round(progress))}%"></div>
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${defects.length > 0 ? `
                                <div class="mt-2 mb-1">
                                    <div class="flex flex-wrap gap-1 mb-1">
                                        ${highDefects > 0 ? `<span class="skill-badge defect-high">High: ${highDefects}</span>` : ''}
                                        ${mediumDefects > 0 ? `<span class="skill-badge defect-medium">Medium: ${mediumDefects}</span>` : ''}
                                        ${lowDefects > 0 ? `<span class="skill-badge defect-low">Low: ${lowDefects}</span>` : ''}
                                    </div>
                                    <div class="space-y-1 mt-2">
                                        ${defects.map((defect, index) => `
                                            <div class="flex justify-between items-center bg-gray-50 dark:bg-gray-800 p-1 text-xs rounded">
                                                <span class="skill-badge defect-${defect.severity} mr-1">${defect.severity}</span>
                                                <div class="flex-grow mx-1 truncate" title="${defect.description}">
                                                    ${defect.description}
                                                </div>
                                                <button class="resolve-defect text-green-500 hover:text-green-700" 
                                                    data-product-id="${product.id}" 
                                                    data-index="${index}">
                                                    <i class="fas fa-check"></i>
                                                </button>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            
                            ${hasBlockingDefects ? `
                                <div class="mt-2 text-xs text-red-500 dark:text-red-400">
                                    <i class="fas fa-exclamation-triangle mr-1"></i>
                                    Does not meet Definition of Done
                                </div>
                                ${reworkButton}
                            ` : ''}
                            
                            ${canMoveToDone ? `
                                <div class="mt-2 text-xs text-green-500 dark:text-green-400">
                                    <i class="fas fa-check-circle mr-1"></i>
                                    Ready to move to Done
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
            }
            
            return itemsHtml;
        }

        // Render random development dialogue
        function renderRandomDevelopmentDialogue() {
            const dialogues = [
                {
                    role: 'Developer',
                    message: 'I just finished the authentication module, moving on to the profile page next.'
                },
                {
                    role: 'Designer',
                    message: 'The new UI components are ready for review. Can someone take a look?'
                },
                {
                    role: 'Frontend Engineer',
                    message: 'I\'m having an issue with the responsive layout on mobile. Anyone free to help?'
                },
                {
                    role: 'Backend Engineer', 
                    message: 'Database optimization is complete, we should see improved query performance now.'
                },
                {
                    role: 'Developer', 
                    message: 'Just pushed my changes to the feature branch, ready for code review.'
                },
                {
                    role: 'Designer', 
                    message: 'User testing results are in - we need to make the checkout button more prominent.'
                },
                {
                    role: 'Frontend Engineer', 
                    message: 'The new animation library is working great, everything feels smoother now.'
                },
                {
                    role: 'Backend Engineer', 
                    message: 'API endpoints for the new feature are deployed and ready for testing.'
                },
                {
                    role: 'QA Engineer',
                    message: 'Found a few edge cases in the latest feature. I\'ll create defect reports for them.'
                },
                {
                    role: 'Scrum Master',
                    message: 'Remember to move your items on the board as you make progress.'
                },
                {
                    role: 'Product Owner',
                    message: 'I\'m impressed with the progress so far, especially with the quality improvements.'
                },
                {
                    role: 'Developer',
                    message: 'I fixed that high-priority defect in the login flow, should be working properly now.'
                }
            ];
            
            // Pick 2 random dialogues
            const shuffled = shuffleArray([...dialogues]);
            const selected = shuffled.slice(0, 2);
            
            return `
                <div class="space-y-4">
                    <div class="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
                        <div class="flex items-start mb-2">
                            <div class="text-primary mr-3 mt-1">
                                <i class="fas fa-clipboard-list"></i>
                            </div>
                            <div>
                                <h4 class="font-semibold">Daily Stand-up</h4>
                                <p class="text-sm text-gray-700 dark:text-gray-300">The team shared updates on their progress and planned today's work.</p>
                            </div>
                        </div>
                        ${selected.map((dialogue, index) => `
                            <div class="dialog-animation ml-8 mt-3 bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg ${index > 0 ? 'mt-2' : ''}">
                                <div class="text-sm">
                                    <span class="font-semibold text-blue-700 dark:text-blue-300">${dialogue.role}:</span>
                                    <span class="text-blue-800 dark:text-blue-200">${dialogue.message}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Render content for an event day
        function renderEventContent(event) {
            return `
                <div id="sprint-content" class="mb-6">
                    <div class="card">
                        <div class="flex justify-between items-start mb-4">
                            <h3 class="font-bold text-lg">Day ${gameState.sprintDay}: ${event.title}</h3>
                            <div class="text-amber-500 text-xl">
                                <i class="fas fa-exclamation-circle"></i>
                            </div>
                        </div>
                        
                        <p class="mb-4 text-gray-700 dark:text-gray-300">${event.description}</p>
                        
                        <div class="bg-amber-50 dark:bg-amber-900/20 p-3 rounded-lg mb-4">
                            <div class="flex items-center text-amber-800 dark:text-amber-200 mb-2">
                                <i class="fas fa-exclamation-triangle mr-2"></i>
                                <span class="font-semibold">Potential Impact:</span>
                            </div>
                            <p class="text-amber-700 dark:text-amber-300 text-sm">${event.impact}</p>
                        </div>
                        
                        <div class="space-y-3 mb-5">
                            ${event.dialogues.map((dialogue, index) => `
                                <div class="dialog-animation ${index > 0 ? 'mt-2' : ''} bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                    <div class="text-sm">
                                        <span class="font-semibold text-primary">${dialogue.speaker}:</span>
                                        <span>${dialogue.message}</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">How will you respond?</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                ${event.options.map(option => `
                                    <button class="event-option p-3 bg-gray-100 dark:bg-gray-700 hover:bg-primary hover:text-white rounded-lg text-left transition-colors" data-id="${option.id}">
                                        <div class="font-semibold mb-1">${option.text}</div>
                                        <div class="text-sm text-gray-700 dark:text-gray-300">${option.effect}</div>
                                    </button>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Handle the response to an event
        function handleEventResponse(eventId, optionId) {
            const event = gameState.events.find(e => e.id === eventId);
            const option = event.options.find(o => o.id === optionId);
            
            // Apply event effects
            applyEventEffect(event, option);
            
            // Clear current event
            gameState.currentEvent = null;
            
            // Update UI
            const sprintContent = document.getElementById('sprint-content');
            if (sprintContent) {
                sprintContent.innerHTML = `
                    <div class="card mb-6">
                        <div class="flex items-center mb-4 text-green-600 dark:text-green-400">
                            <i class="fas fa-check-circle text-2xl mr-3"></i>
                            <h3 class="font-bold text-lg">Decision Made</h3>
                        </div>
                        
                        <p class="mb-4">You chose: <span class="font-semibold">${option.text}</span></p>
                        
                        <div class="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg mb-4">
                            <div class="text-sm">
                                <span class="font-semibold text-blue-700 dark:text-blue-300">Effect:</span>
                                <span class="text-blue-800 dark:text-blue-200">${option.effect}</span>
                            </div>
                        </div>
                        
                        <div class="dialog-animation bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                            <div class="text-sm">
                                <span class="font-semibold text-primary">Team:</span>
                                <span>Let's make the best of this situation and continue with our sprint tasks.</span>
                            </div>
                        </div>
                    </div>
                    
                    ${renderKanbanBoard()}
                `;
            }
            
            // Update sprint actions
            const sprintActions = document.getElementById('sprint-actions');
            if (sprintActions) {
                sprintActions.innerHTML = `
                    <button id="next-day" class="btn btn-primary">
                        ${gameState.sprintDay === gameState.sprintLength ? 'End Sprint' : 'Next Day'}
                    </button>
                `;
                
                document.getElementById('next-day').addEventListener('click', () => {
                    advanceSprintDay();
                });
            }
            
            // Setup kanban drag and drop after rendering
            setupKanbanDragDrop();
            setupDefectResolving();
            setupReworkTasks();
        }

        // Apply the effect of an event response
        function applyEventEffect(event, option) {
            // Effects depend on the event and option
            switch (event.id) {
                case 'sickDay':
                    if (option.id === 'redistribute') {
                        // Slight reduction in productivity but maintains morale
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.9));
                    } else if (option.id === 'postpone') {
                        // Larger reduction in productivity but less stress on team
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.8));
                        gameState.teamMorale = Math.min(100, gameState.teamMorale + 5);
                    }
                    break;
                    
                case 'techIssue':
                    if (option.id === 'focusLocal') {
                        // Some productivity maintained but may lead to issues
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.85));
                        
                        // Add defects to items in progress
                        Object.keys(gameState.taskStages).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskStages[id] === 'inProgress') {
                                // 50% chance to add a new defect
                                if (Math.random() < 0.5) {
                                    if (!gameState.taskDefects[id]) {
                                        gameState.taskDefects[id] = [];
                                    }
                                    gameState.taskDefects[id].push({
                                        severity: Math.random() < 0.3 ? 'high' : 'medium',
                                        description: 'Integration issue due to build server problems'
                                    });
                                }
                            }
                        });
                    } else if (option.id === 'documentCode') {
                        // More productivity lost but better code quality
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.7));
                        gameState.teamMorale = Math.min(100, gameState.teamMorale + 10);
                    }
                    break;
                    
                case 'newRequirement':
                    if (option.id === 'negotiate') {
                        // No immediate impact on productivity but slight morale hit
                        gameState.teamMorale = Math.max(0, gameState.teamMorale - 5);
                    } else if (option.id === 'accommodate') {
                        // Reduced productivity due to scope change but client is happy
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.8));
                        gameState.teamMorale = Math.max(0, gameState.teamMorale - 10);
                        
                        // Add high-priority defects to simulate rushed work
                        Object.keys(gameState.taskStages).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskStages[id] === 'inProgress' || gameState.taskStages[id] === 'testing') {
                                // 40% chance to add a new defect
                                if (Math.random() < 0.4) {
                                    if (!gameState.taskDefects[id]) {
                                        gameState.taskDefects[id] = [];
                                    }
                                    gameState.taskDefects[id].push({
                                        severity: Math.random() < 0.3 ? 'high' : 'medium',
                                        description: 'Integration issue with new requirements'
                                    });
                                }
                            }
                        });
                    }
                    break;
                    
                case 'teamConflict':
                    if (option.id === 'codeReview') {
                        // Short-term productivity hit but better alignment
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.9));
                        gameState.teamMorale = Math.min(100, gameState.teamMorale + 10);
                        
                        // Reduce defects to simulate better code quality
                        Object.keys(gameState.taskDefects).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskDefects[id] && gameState.taskDefects[id].length > 0) {
                                // 50% chance to fix a defect
                                if (Math.random() < 0.5) {
                                    gameState.taskDefects[id].pop();
                                }
                            }
                        });
                    } else if (option.id === 'splitWork') {
                        // Maintains productivity but may cause issues later
                        gameState.teamMorale = Math.max(0, gameState.teamMorale - 15);
                        
                        // Add defects to simulate integration issues
                        Object.keys(gameState.taskStages).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskStages[id] === 'inProgress') {
                                // 60% chance to add a new defect
                                if (Math.random() < 0.6) {
                                    if (!gameState.taskDefects[id]) {
                                        gameState.taskDefects[id] = [];
                                    }
                                    gameState.taskDefects[id].push({
                                        severity: 'medium',
                                        description: 'Integration issue due to split implementation approaches'
                                    });
                                }
                            }
                        });
                    }
                    break;
                    
                case 'inspiration':
                    if (option.id === 'implementNow') {
                        // Higher quality but reduced productivity
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.85));
                        gameState.teamMorale = Math.min(100, gameState.teamMorale + 15);
                        
                        // Move back design items to in-progress to implement improvements
                        Object.keys(gameState.taskStages).forEach(idStr => {
                            const id = parseInt(idStr);
                            const product = gameState.selectedProducts.find(p => p.id === parseInt(id));
                            if (product && product.skills.includes('design') && gameState.taskStages[id] === 'testing') {
                                gameState.taskStages[id] = 'inProgress';
                                gameState.taskProgress[id] = 50; // Start at 50% progress
                            }
                        });
                    } else if (option.id === 'documentForLater') {
                        // No productivity impact but designer morale hit
                        gameState.teamMorale = Math.max(0, gameState.teamMorale - 10);
                    }
                    break;
                    
                case 'expertHelp':
                    if (option.id === 'focusTechnical') {
                        // Better code quality but fewer features
                        gameState.assignedStoryPoints = Math.max(0, Math.floor(gameState.assignedStoryPoints * 0.9));
                        gameState.teamMorale = Math.min(100, gameState.teamMorale + 10);
                        
                        // Fix some defects
                        Object.keys(gameState.taskDefects).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskDefects[id] && gameState.taskDefects[id].length > 0) {
                                // 80% chance to fix defects
                                if (Math.random() < 0.8) {
                                    // Fix up to 2 defects, prioritizing high severity ones
                                    const highDefects = gameState.taskDefects[id].filter(d => d.severity === 'high');
                                    if (highDefects.length > 0) {
                                        const index = gameState.taskDefects[id].indexOf(highDefects[0]);
                                        gameState.taskDefects[id].splice(index, 1);
                                    } else {
                                        gameState.taskDefects[id].shift();
                                    }
                                    
                                    // Maybe fix a second defect
                                    if (gameState.taskDefects[id].length > 0 && Math.random() < 0.5) {
                                        gameState.taskDefects[id].shift();
                                    }
                                }
                            }
                        });
                    } else if (option.id === 'speedFeature') {
                        // Productivity boost
                        gameState.assignedStoryPoints = Math.floor(gameState.assignedStoryPoints * 1.1);
                        
                        // Boost progress of in-progress items
                        Object.keys(gameState.taskStages).forEach(idStr => {
                            const id = parseInt(idStr);
                            if (gameState.taskStages[id] === 'inProgress') {
                                gameState.taskProgress[id] += 20; // 20% boost
                                
                                // If complete, move to testing
                                if (gameState.taskProgress[id] >= 100) {
                                    gameState.taskStages[id] = 'testing';
                                    gameState.taskProgress[id] = 0;
                                    
                                    // Generate defects when moving to testing
                                    if (!gameState.taskDefects[id]) {
                                        gameState.taskDefects[id] = generateDefects(id);
                                    }
                                }
                            }
                        });
                    }
                    break;
            }
            
            // Update morale display
            const moraleDisplay = document.getElementById('team-morale');
            if (moraleDisplay) {
                moraleDisplay.textContent = `${gameState.teamMorale}%`;
            }
        }

        // Advance to the next day of the sprint
        function advanceSprintDay() {
            if (gameState.sprintDay === gameState.sprintLength) {
                // End of sprint - calculate results
                calculateSprintResults();
                
                // Go to definition of done phase if first sprint completed
                // Otherwise go to retrospective
                if (gameState.currentSprint === 0) {
                    renderPhase('definitionOfDone');
                } else {
                    renderPhase('retrospective');
                }
            } else {
                // Advance to next day
                gameState.sprintDay++;
                renderPhase('sprint');
            }
        }

        // Render Definition of Done phase
        function renderDefinitionOfDonePhase(container) {
            let optionsHtml = '';
            
            definitionOfDoneOptions.forEach(option => {
                optionsHtml += `
                    <div class="definition-option card card-hover mb-4 cursor-pointer">
                        <div class="flex justify-between items-start mb-2">
                            <h4 class="font-semibold">${option.text}</h4>
                            <div class="text-primary text-xl">
                                <i class="fas fa-check-circle"></i>
                            </div>
                        </div>
                        <p class="text-sm text-gray-700 dark:text-gray-300 mb-3">${option.description}</p>
                        <div class="bg-gray-50 dark:bg-gray-800 rounded p-2 text-sm">
                            <div class="mb-1">
                                <span class="font-semibold">Efficiency:</span> 
                                <span class="${option.effect.efficiency >= 1 ? 'text-green-600 dark:text-green-400' : 'text-amber-600 dark:text-amber-400'}">
                                    ${option.effect.efficiency >= 1 ? '+' : ''}${((option.effect.efficiency - 1) * 100).toFixed(0)}%
                                </span>
                            </div>
                            <div>
                                <span class="font-semibold">Quality:</span> 
                                <span class="${option.effect.qualityBoost >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">
                                    ${option.effect.qualityBoost >= 0 ? '+' : ''}${option.effect.qualityBoost}%
                                </span>
                            </div>
                        </div>
                        <button class="select-definition w-full mt-3 py-2 px-4 rounded-md bg-gray-100 dark:bg-gray-700 hover:bg-primary hover:text-white transition-colors" data-id="${option.id}">
                            Select
                        </button>
                    </div>
                `;
            });
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="mb-6">
                        <h2 class="text-2xl font-bold mb-2">Define "Done" for Your Team</h2>
                        <p class="text-gray-700 dark:text-gray-300">Choose the criteria that your team will use to consider work complete</p>
                    </div>
                    
                    <div class="card mb-6">
                        <h3 class="font-bold mb-4">Definition of "Done"</h3>
                        
                        <div class="panel-blue mb-4">
                            <div class="text-blue-800 dark:text-blue-200">
                                <p class="font-semibold mb-2">All definitions of "Done" include:</p>
                                <ul class="list-disc list-inside ml-2 space-y-1 text-sm">
                                    <li>Code is committed to version control</li>
                                    <li>Code passes all automated tests</li>
                                    <li>Documentation is updated</li>
                                    <li>Product Owner has accepted the feature</li>
                                    <li>It can't have any unresolved high-severity defects</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p class="mb-4">Additionally, you need to decide how many medium or low-severity defects should be allowed:</p>
                        
                        <div class="mb-4">
                            ${optionsHtml}
                        </div>
                        
                        <div class="bg-amber-50 dark:bg-amber-900/20 p-3 rounded-lg">
                            <div class="flex items-start">
                                <div class="text-amber-700 dark:text-amber-300 mr-3 mt-1">
                                    <i class="fas fa-lightbulb"></i>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-amber-700 dark:text-amber-300 mb-1">Why This Matters</h4>
                                    <p class="text-amber-800 dark:text-amber-200 text-sm">
                                        A stricter Definition of Done may slow down delivery initially but leads to higher quality and less rework. 
                                        A more lenient definition enables faster delivery but may require more maintenance later.
                                    </p>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-rose-50 dark:bg-rose-900/20 p-3 rounded-lg mt-4">
                            <div class="flex items-start">
                                <div class="text-rose-700 dark:text-rose-300 mr-3 mt-1">
                                    <i class="fas fa-sync-alt"></i>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-rose-700 dark:text-rose-300 mb-1">Rework Process</h4>
                                    <p class="text-rose-800 dark:text-rose-200 text-sm">
                                        Tasks that don't meet the Definition of Done must be moved back to "In Progress" for rework.
                                        Each rework reduces the chance of defects in future testing cycles.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add event listeners
            const definitionButtons = document.querySelectorAll('.select-definition');
            definitionButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const definitionId = button.getAttribute('data-id');
                    selectDefinitionOfDone(definitionId);
                });
            });
        }

        // Select a Definition of Done
        function selectDefinitionOfDone(definitionId) {
            const definition = definitionOfDoneOptions.find(d => d.id === definitionId);
            
            // Store the selection
            gameState.definitionOfDone = definition;
            gameState.sprintEfficiency = definition.effect.efficiency;
            
            // Show notification
            showNotification(`Definition of Done selected: ${definition.text}`, 'success');
            
            // Move to retrospective phase
            renderPhase('retrospective');
        }

        // Calculate the results of the sprint
        function calculateSprintResults() {
            // Base completion is assigned story points
            let completedPoints = 0;
            let quality = 80; // Base quality percentage
            
            // Count points for tasks in the "done" stage
            const completedProducts = [];
            const carriedOverTasks = [];
            
            gameState.selectedProducts.forEach(product => {
                const stage = gameState.taskStages[product.id];
                
                // Handle carried over tasks specially
                const isCarriedOver = gameState.carriedOverTasks.some(t => t.id === product.id);
                
                if (stage === 'done') {
                    // If product is completed, add its points to completed points
                    if (isCarriedOver) {
                        // For carried over tasks, use the remaining points from last sprint
                        const carriedTask = gameState.carriedOverTasks.find(t => t.id === product.id);
                        completedPoints += carriedTask.remainingPoints;
                    } else {
                        completedPoints += product.storyPoints;
                    }
                    
                    // Add to completed products for this sprint
                    completedProducts.push(product);
                } else {
                    // If task is not done, it needs to be carried over to next sprint
                    // Calculate remaining points based on current progress
                    const remainingPoints = calculateRemainingStoryPoints(product.id);
                    
                    if (remainingPoints > 0) {
                        // Create or update the carried over task
                        carriedOverTasks.push({
                            ...product,
                            remainingPoints: remainingPoints,
                            stage: stage,
                            progress: gameState.taskProgress[product.id] || 0,
                            defects: gameState.taskDefects[product.id] || []
                        });
                    }
                }
            });
            
            // Apply strategy effects
            if (gameState.selectedStrategies.includes('focusQuality')) {
                quality += 15;
            }
            
            if (gameState.selectedStrategies.includes('focusSpeed')) {
                quality -= 10;
            }
            
            if (gameState.selectedStrategies.includes('pairProgramming')) {
                quality += 10;
            }
            
            if (gameState.selectedStrategies.includes('codeTesting')) {
                quality += 20;
            }
            
            if (gameState.selectedStrategies.includes('dailyMeetings')) {
                quality += 5;
            }
            
            if (gameState.selectedStrategies.includes('overtime')) {
                gameState.teamMorale = Math.max(0, gameState.teamMorale - 15);
            }
            
            // Apply efficiency modifier from Definition of Done
            if (gameState.definitionOfDone) {
                quality += gameState.definitionOfDone.effect.qualityBoost;
            }
            
            // Apply team morale effect
            // If morale is below 50%, it reduces quality
            if (gameState.teamMorale < 50) {
                const moraleEffect = 0.5 + (gameState.teamMorale / 100);
                quality = Math.floor(quality * moraleEffect);
            }
            // If morale is above 80%, it increases quality
            else if (gameState.teamMorale > 80) {
                const moraleBonus = 1 + ((gameState.teamMorale - 80) / 200); // Small bonus
                quality = Math.floor(quality * moraleBonus);
            }
            
            // Ensure quality is within bounds
            quality = Math.max(0, Math.min(100, quality));
            
            // Calculate score based on completed points and quality
            const score = Math.floor(completedPoints * (quality / 100));
            
            // Count reworked tasks
            let totalReworkCount = 0;
            Object.keys(gameState.reworkCount).forEach(id => {
                totalReworkCount += gameState.reworkCount[id];
            });
            
            // Store sprint results
            gameState.sprintResults.push({
                sprint: gameState.currentSprint + 1,
                assignedPoints: gameState.assignedStoryPoints,
                completedPoints: completedPoints,
                unassignedPoints: gameState.unassignedStoryPoints,
                quality: quality,
                teamMorale: gameState.teamMorale,
                strategies: gameState.selectedStrategies.map(id => {
                    const strategy = teamStrategies.find(s => s.id === id);
                    return strategy.name;
                }),
                completedProducts: completedProducts,
                carriedOverTasks: carriedOverTasks,
                score: score,
                sprintLength: gameState.sprintLength,
                definitionOfDone: gameState.definitionOfDone ? gameState.definitionOfDone.text : null,
                reworkedTasks: totalReworkCount
            });
            
            // Update game state
            gameState.completedStoryPoints += completedPoints;
            
            // Update carried over tasks for next sprint
            gameState.carriedOverTasks = carriedOverTasks;
        }

        // Generate retrospective comments based on sprint performance
        function generateRetrospectiveComments() {
            const sprintResult = gameState.sprintResults[gameState.currentSprint];
            const completionRate = sprintResult.completedPoints / (sprintResult.assignedPoints + sprintResult.unassignedPoints);
            
            // Initialize feedback categories
            const wellDone = [];
            const improvements = [];
            const actionItems = [];
            
            // Analysis based on performance
            if (completionRate >= 0.9) {
                wellDone.push("We completed almost all our planned work!");
            } else if (completionRate >= 0.7) {
                wellDone.push("We made good progress on our sprint goals.");
            } else {
                improvements.push("We struggled to complete our planned work.");
            }
            
            if (sprintResult.quality >= 85) {
                wellDone.push("Our quality was excellent this sprint.");
            } else if (sprintResult.quality < 60) {
                improvements.push("We need to focus more on quality.");
                actionItems.push("Introduce more rigorous code reviews");
            }
            
            if (sprintResult.teamMorale >= 85) {
                wellDone.push("Team morale is really high.");
            } else if (sprintResult.teamMorale < 50) {
                improvements.push("Team morale is concerning.");
                actionItems.push("Schedule team building activities");
            }
            
            // Check if we took on too much work
            if (sprintResult.unassignedPoints > 10) {
                improvements.push("We had a lot of unassigned story points.");
                actionItems.push("Be more realistic about our capacity in planning");
            }
            
            // Check strategy effectiveness
            if (gameState.selectedStrategies.includes('focusQuality') && sprintResult.quality >= 85) {
                wellDone.push("The 'Focus on Quality' strategy paid off.");
            }
            
            if (gameState.selectedStrategies.includes('overtime') && sprintResult.teamMorale < 70) {
                improvements.push("Overtime negatively impacted our team morale.");
                actionItems.push("Avoid excessive overtime in future sprints");
            }
            
            // Check if there are too many incomplete story points
            const incompleteStoryPoints = sprintResult.assignedPoints - sprintResult.completedPoints;
            if (incompleteStoryPoints > 10) {
                actionItems.push(`Consider extending our sprint length (${incompleteStoryPoints} story points incomplete)`);
                gameState.retrospectiveDecisions.sprintLength = true;
            }
            
            // Comment on carried over tasks
            if (sprintResult.carriedOverTasks.length > 0) {
                const carriedOverPoints = sprintResult.carriedOverTasks.reduce((sum, task) => sum + task.remainingPoints, 0);
                improvements.push(`We have ${sprintResult.carriedOverTasks.length} tasks with ${carriedOverPoints} points carried over to next sprint.`);
                actionItems.push("Be more cautious with our commitments in the next sprint");
            }
            
            // Comment on reworked tasks
            if (sprintResult.reworkedTasks > 0) {
                improvements.push(`We had to rework ${sprintResult.reworkedTasks} tasks to meet our Definition of Done.`);
                if (sprintResult.reworkedTasks > 2) {
                    actionItems.push("Improve quality checks earlier in the development process");
                }
            }
            
            // Feedback about defects
            const defectCounts = {
                high: 0,
                medium: 0,
                low: 0
            };
            
            // Count defects that prevented "done" status
            Object.keys(gameState.taskStages).forEach(idStr => {
                const id = parseInt(idStr);
                if (gameState.taskStages[id] === 'testing' && !meetsDefinitionOfDone(id)) {
                    const defects = gameState.taskDefects[id] || [];
                    defectCounts.high += defects.filter(d => d.severity === 'high').length;
                    defectCounts.medium += defects.filter(d => d.severity === 'medium').length;
                    defectCounts.low += defects.filter(d => d.severity === 'low').length;
                }
            });
            
            if (defectCounts.high > 0) {
                improvements.push(`We had ${defectCounts.high} high-severity defects that blocked completion.`);
                actionItems.push("Implement better testing early in development");
            }
            
            if (defectCounts.medium + defectCounts.low > 5) {
                improvements.push(`We had too many medium and low-severity defects (${defectCounts.medium + defectCounts.low} total).`);
                
                if (gameState.definitionOfDone && gameState.definitionOfDone.id === 'lenient') {
                    actionItems.push("Consider a stricter Definition of Done");
                }
            }
            
            // Team composition suggestions
            if (sprintResult.quality < 70 || completionRate < 0.7) {
                const missingSkills = [];
                
                // Check if we needed more frontend developers
                const frontendTasks = gameState.selectedProducts.filter(p => p.skills.includes('frontend')).length;
                const frontendDevs = gameState.team.filter(e => e.skills.includes('frontend')).length;
                if (frontendTasks > frontendDevs * 2) {
                    missingSkills.push("frontend");
                }
                
                // Check if we needed more backend developers
                const backendTasks = gameState.selectedProducts.filter(p => p.skills.includes('backend')).length;
                const backendDevs = gameState.team.filter(e => e.skills.includes('backend')).length;
                if (backendTasks > backendDevs * 2) {
                    missingSkills.push("backend");
                }
                
                // Check if we needed more designers
                const designTasks = gameState.selectedProducts.filter(p => p.skills.includes('design')).length;
                const designers = gameState.team.filter(e => e.skills.includes('design')).length;
                if (designTasks > designers * 2) {
                    missingSkills.push("design");
                }
                
                if (missingSkills.length > 0) {
                    actionItems.push(`Consider hiring more ${missingSkills.join(" and ")} specialists`);
                    gameState.retrospectiveDecisions.teamChanges = true;
                }
            }
            
            // Ensure we have at least some feedback in each category
            if (wellDone.length === 0) wellDone.push("We collaborated well as a team.");
            if (improvements.length === 0) improvements.push("We could improve our estimation accuracy.");
            if (actionItems.length === 0) actionItems.push("Continue with our current process, but monitor progress more closely.");
            
            return {
                wellDone,
                improvements,
                actionItems
            };
        }

        // Render Retrospective Phase
        function renderRetrospectivePhase(container) {
            const sprintResult = gameState.sprintResults[gameState.currentSprint];
            const feedback = generateRetrospectiveComments();
            
            // Build retrospective chat dialogues
            let retroContent = '';
            
            // Initialize question state
            let currentQuestion = 0;
            const questions = [];
            
            // Add sprint length question if there were too many incomplete story points
            if (gameState.retrospectiveDecisions.sprintLength) {
                const incompleteStoryPoints = sprintResult.assignedPoints - sprintResult.completedPoints;
                questions.push({
                    question: `There were ${incompleteStoryPoints} incomplete story points. Should we adjust our sprint length?`,
                    options: [
                        { id: "keep-length", text: "Keep the current sprint length" },
                        { id: "reset-length", text: "Reset to 2 weeks" },
                        { id: "increase-length", text: "Increase to 3 weeks" },
                        { id: "increase-length-more", text: "Increase to 4 weeks" }
                    ]
                });
            }
            
            // Add team changes question if it was identified as an issue
            if (gameState.retrospectiveDecisions.teamChanges) {
                questions.push({
                    question: "Should we modify our team composition?",
                    options: [
                        { id: "keep-team", text: "Keep the current team" },
                        { id: "hire-specialist", text: "Hire more specialists" },
                        { id: "cross-train", text: "Invest in cross-training" }
                    ]
                });
            }
            
            // Add process improvement question
            questions.push({
                question: "What process improvements should we focus on?",
                options: [
                    { id: "better-planning", text: "More accurate sprint planning" },
                    { id: "daily-communication", text: "Improve daily communication" },
                    { id: "quality-focus", text: "Focus on quality over quantity" }
                ]
            });
            
            // Create the retrospective UI
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Sprint ${sprintResult.sprint} Retrospective</h2>
                            <p class="text-gray-700 dark:text-gray-300">Reflect on your team's performance and plan improvements</p>
                        </div>
                        <div class="mt-4 md:mt-0">
                            <div class="panel-blue text-blue-800 dark:text-blue-200 font-semibold">
                                <i class="fas fa-comment-dots mr-2"></i> Team Discussion
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mb-6">
                        <h3 class="font-bold mb-4">What went well?</h3>
                        <div id="well-done-chat" class="border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-6 max-h-48 overflow-y-auto">
                            <div class="typing-container" id="typing-well-done">
                                <div class="flex items-center mb-3">
                                    <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <div class="typing-animation">
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <h3 class="font-bold mb-4">What could be improved?</h3>
                        <div id="improvements-chat" class="border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-6 max-h-48 overflow-y-auto">
                            <div class="typing-container" id="typing-improvements">
                                <div class="flex items-center mb-3">
                                    <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <div class="typing-animation">
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <h3 class="font-bold mb-4">Action Items</h3>
                        <div id="action-items-chat" class="border border-gray-200 dark:border-gray-700 rounded-lg p-4 mb-6 max-h-48 overflow-y-auto">
                            <div class="typing-container" id="typing-actions">
                                <div class="flex items-center mb-3">
                                    <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                        <i class="fas fa-user"></i>
                                    </div>
                                    <div class="typing-animation">
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                        <span class="typing-dot"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="decisions-container" class="card mb-6" style="display: none;">
                        <h3 class="font-bold mb-4">Your Decisions</h3>
                        <div id="current-question-container">
                            <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-4">
                                <div class="font-semibold text-blue-700 dark:text-blue-300 mb-2" id="current-question">
                                    ${questions.length > 0 ? questions[0].question : "No questions to answer."}
                                </div>
                                <div class="grid grid-cols-1 gap-2 mt-4" id="decision-options">
                                    ${questions.length > 0 ? questions[0].options.map(option => `
                                        <button class="decision-option text-left p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-primary hover:text-white transition-colors" data-id="${option.id}">
                                            ${option.text}
                                        </button>
                                    `).join('') : ''}
                                </div>
                            </div>
                        </div>
                        <div id="previous-decisions" class="space-y-3"></div>
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="back-btn" class="btn btn-secondary" disabled>
                            Back
                        </button>
                        <button id="continue-to-summary" class="btn btn-primary" style="display: none;">
                            Continue to Sprint Summary
                        </button>
                    </div>
                </div>
            `;
            
            // Simulate chat messages for "What went well"
            setTimeout(() => {
                const wellDoneChat = document.getElementById('well-done-chat');
                const typingWellDone = document.getElementById('typing-well-done');
                
                if (wellDoneChat && typingWellDone) {
                    typingWellDone.remove();
                    
                    // Add Scrum Master intro
                    const scrumMasterMessage = document.createElement('div');
                    scrumMasterMessage.className = 'flex mb-4';
                    scrumMasterMessage.innerHTML = `
                        <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white mr-2">
                            <i class="fas fa-user-tie"></i>
                        </div>
                        <div class="chat-bubble chat-left">
                            <div class="font-semibold mb-1">Scrum Master</div>
                            <div>Great job everyone! Let's start by discussing what went well this sprint. Who wants to start?</div>
                        </div>
                    `;
                    wellDoneChat.appendChild(scrumMasterMessage);
                    
                    // Add team member comments
                    feedback.wellDone.forEach((comment, index) => {
                        setTimeout(() => {
                            const teamMemberIdx = index % gameState.team.length;
                            const teamMember = gameState.team[teamMemberIdx];
                            
                            const messageEl = document.createElement('div');
                            messageEl.className = 'flex mb-4 dialog-animation';
                            messageEl.innerHTML = `
                                <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                    <i class="${teamMember.icon}"></i>
                                </div>
                                <div class="chat-bubble chat-left">
                                    <div class="font-semibold mb-1">${teamMember.name}</div>
                                    <div>${comment}</div>
                                </div>
                            `;
                            wellDoneChat.appendChild(messageEl);
                            wellDoneChat.scrollTop = wellDoneChat.scrollHeight;
                            
                            // Start improvements section after last "well done" comment
                            if (index === feedback.wellDone.length - 1) {
                                startImprovementsChat(feedback);
                            }
                        }, 1000 + (index * 1500));
                    });
                }
            }, 1000);
            
            // Function to start improvements chat
            function startImprovementsChat(feedback) {
                const improvementsChat = document.getElementById('improvements-chat');
                const typingImprovements = document.getElementById('typing-improvements');
                
                if (improvementsChat && typingImprovements) {
                    typingImprovements.remove();
                    
                    // Add Scrum Master transition
                    const scrumMasterMessage = document.createElement('div');
                    scrumMasterMessage.className = 'flex mb-4';
                    scrumMasterMessage.innerHTML = `
                        <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white mr-2">
                            <i class="fas fa-user-tie"></i>
                        </div>
                        <div class="chat-bubble chat-left">
                            <div class="font-semibold mb-1">Scrum Master</div>
                            <div>Now let's discuss what could be improved. Remember, this is about the process, not blaming individuals.</div>
                        </div>
                    `;
                    improvementsChat.appendChild(scrumMasterMessage);
                    
                    // Add team member comments
                    feedback.improvements.forEach((comment, index) => {
                        setTimeout(() => {
                            const teamMemberIdx = (index + 2) % gameState.team.length;
                            const teamMember = gameState.team[teamMemberIdx];
                            
                            const messageEl = document.createElement('div');
                            messageEl.className = 'flex mb-4 dialog-animation';
                            messageEl.innerHTML = `
                                <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                    <i class="${teamMember.icon}"></i>
                                </div>
                                <div class="chat-bubble chat-left">
                                    <div class="font-semibold mb-1">${teamMember.name}</div>
                                    <div>${comment}</div>
                                </div>
                            `;
                            improvementsChat.appendChild(messageEl);
                            improvementsChat.scrollTop = improvementsChat.scrollHeight;
                            
                            // Start action items section after last improvement comment
                            if (index === feedback.improvements.length - 1) {
                                startActionItemsChat(feedback);
                            }
                        }, 1000 + (index * 1500));
                    });
                }
            }
            
            // Function to start action items chat
            function startActionItemsChat(feedback) {
                const actionItemsChat = document.getElementById('action-items-chat');
                const typingActions = document.getElementById('typing-actions');
                
                if (actionItemsChat && typingActions) {
                    typingActions.remove();
                    
                    // Add Scrum Master transition
                    const scrumMasterMessage = document.createElement('div');
                    scrumMasterMessage.className = 'flex mb-4';
                    scrumMasterMessage.innerHTML = `
                        <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white mr-2">
                            <i class="fas fa-user-tie"></i>
                        </div>
                        <div class="chat-bubble chat-left">
                            <div class="font-semibold mb-1">Scrum Master</div>
                            <div>Great feedback everyone! Let's define some action items for our next sprint.</div>
                        </div>
                    `;
                    actionItemsChat.appendChild(scrumMasterMessage);
                    
                    // Add team member comments
                    feedback.actionItems.forEach((comment, index) => {
                        setTimeout(() => {
                            const teamMemberIdx = (index + 1) % gameState.team.length;
                            const teamMember = gameState.team[teamMemberIdx];
                            
                            const messageEl = document.createElement('div');
                            messageEl.className = 'flex mb-4 dialog-animation';
                            messageEl.innerHTML = `
                                <div class="w-8 h-8 rounded-full bg-primary/20 flex items-center justify-center text-primary mr-2">
                                    <i class="${teamMember.icon}"></i>
                                </div>
                                <div class="chat-bubble chat-left">
                                    <div class="font-semibold mb-1">${teamMember.name}</div>
                                    <div>${comment}</div>
                                </div>
                            `;
                            actionItemsChat.appendChild(messageEl);
                            actionItemsChat.scrollTop = actionItemsChat.scrollHeight;
                            
                            // Show the decision container after all chats are completed
                            if (index === feedback.actionItems.length - 1) {
                                setTimeout(() => {
                                    // Final scrum master message
                                    const finalMessage = document.createElement('div');
                                    finalMessage.className = 'flex mb-4 dialog-animation';
                                    finalMessage.innerHTML = `
                                        <div class="w-8 h-8 rounded-full bg-blue-500 flex items-center justify-center text-white mr-2">
                                            <i class="fas fa-user-tie"></i>
                                        </div>
                                        <div class="chat-bubble chat-left">
                                            <div class="font-semibold mb-1">Scrum Master</div>
                                            <div>As Scrum Master, I'll now ask for your decisions on some important changes for our next sprint.</div>
                                        </div>
                                    `;
                                    actionItemsChat.appendChild(finalMessage);
                                    
                                    setTimeout(() => {
                                        document.getElementById('decisions-container').style.display = 'block';
                                        setupDecisionHandlers();
                                    }, 1000);
                                }, 1000);
                            }
                        }, 1000 + (index * 1500));
                    });
                }
            }
            
            // Function to handle decision options
            function setupDecisionHandlers() {
                const decisionOptions = document.querySelectorAll('.decision-option');
                decisionOptions.forEach(option => {
                    option.addEventListener('click', () => {
                        const decisionId = option.getAttribute('data-id');
                        const questionText = document.getElementById('current-question').textContent;
                        const optionText = option.textContent.trim();
                        
                        // Save the decision
                        handleDecision(decisionId, questionText, optionText);
                        
                        // Move to next question or finish
                        currentQuestion++;
                        if (currentQuestion < questions.length) {
                            updateCurrentQuestion(questions[currentQuestion]);
                        } else {
                            finishRetrospective();
                        }
                    });
                });
            }
            
            // Function to handle a decision
            function handleDecision(decisionId, questionText, optionText) {
                // Add decision to previous decisions list
                const previousDecisions = document.getElementById('previous-decisions');
                const decisionEl = document.createElement('div');
                decisionEl.className = 'bg-gray-50 dark:bg-gray-800 p-3 rounded-lg';
                decisionEl.innerHTML = `
                    <div class="font-semibold mb-1">${questionText}</div>
                    <div class="text-sm text-primary">Decision: ${optionText}</div>
                `;
                previousDecisions.appendChild(decisionEl);
                
                // Apply effects of decision
                if (decisionId === 'increase-length') {
                    gameState.sprintLength = 21;
                    gameState.retrospectiveDecisions.sprintLength = 21;
                } else if (decisionId === 'increase-length-more') {
                    gameState.sprintLength = 28;
                    gameState.retrospectiveDecisions.sprintLength = 28;
                } else if (decisionId === 'reset-length') {
                    gameState.sprintLength = 14;
                    gameState.retrospectiveDecisions.sprintLength = 14;
                }
                // Other decision effects would be implemented here
            }
            
            // Function to update the current question
            function updateCurrentQuestion(question) {
                const questionContainer = document.getElementById('current-question');
                const optionsContainer = document.getElementById('decision-options');
                
                questionContainer.textContent = question.question;
                
                let optionsHtml = '';
                question.options.forEach(option => {
                    optionsHtml += `
                        <button class="decision-option text-left p-3 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg hover:bg-primary hover:text-white transition-colors" data-id="${option.id}">
                            ${option.text}
                        </button>
                    `;
                });
                
                optionsContainer.innerHTML = optionsHtml;
                setupDecisionHandlers();
            }
            
            // Function to finish the retrospective
            function finishRetrospective() {
                // Hide question container
                document.getElementById('current-question-container').style.display = 'none';
                
                // Show summary message
                const previousDecisions = document.getElementById('previous-decisions');
                const summaryEl = document.createElement('div');
                summaryEl.className = 'bg-green-50 dark:bg-green-900/20 p-4 rounded-lg text-green-800 dark:text-green-200';
                summaryEl.innerHTML = `
                    <div class="flex items-start">
                        <i class="fas fa-check-circle text-green-600 dark:text-green-400 text-xl mr-3 mt-1"></i>
                        <div>
                            <div class="font-bold mb-2">Retrospective Complete</div>
                            <p>Your decisions have been recorded and will be applied to the next sprint. Let's review the sprint summary before continuing.</p>
                        </div>
                    </div>
                `;
                previousDecisions.appendChild(summaryEl);
                
                // Show continue button
                document.getElementById('continue-to-summary').style.display = 'block';
            }
            
            // Add event listener for continue button
            document.getElementById('continue-to-summary').addEventListener('click', () => {
                renderPhase('summary');
            });
        }

        // Render Sprint Summary Phase
        function renderSprintSummaryPhase(container) {
            const sprintResult = gameState.sprintResults[gameState.currentSprint];
            
            // Calculate completion percentage (based only on assigned points)
            const completionPercentage = sprintResult.assignedPoints > 0 ? Math.round((sprintResult.completedPoints / sprintResult.assignedPoints) * 100) : 0;
            
            // Prepare completed products list
            let completedProductsHtml = '';
            if (sprintResult.completedProducts.length > 0) {
                completedProductsHtml = '<div class="space-y-2">';
                sprintResult.completedProducts.forEach(product => {
                    const reworkCount = gameState.reworkCount[product.id] || 0;
                    const reworkBadge = reworkCount > 0 ? 
                        `<span class="ml-2 rework-badge">Reworked ${reworkCount}x</span>` : '';
                    
                    completedProductsHtml += `
                        <div class="bg-white dark:bg-gray-750 p-2 rounded flex justify-between items-center">
                            <span>${product.name} ${reworkBadge}</span>
                            <span class="font-semibold">${product.storyPoints} pts</span>
                        </div>
                    `;
                });
                completedProductsHtml += '</div>';
            } else {
                completedProductsHtml = '<p class="text-gray-700 dark:text-gray-300 italic">No products were completed this sprint</p>';
            }
            
            // Prepare carried over tasks list
            let carriedOverHtml = '';
            if (sprintResult.carriedOverTasks && sprintResult.carriedOverTasks.length > 0) {
                carriedOverHtml = `
                    <div class="bg-amber-50 dark:bg-amber-900/20 p-4 rounded-lg mb-6">
                        <div class="flex items-start">
                            <div class="text-amber-700 dark:text-amber-300 mr-3 mt-1">
                                <i class="fas fa-exclamation-triangle"></i>
                            </div>
                            <div>
                                <h4 class="font-semibold text-amber-700 dark:text-amber-300 mb-2">Carried Over Tasks</h4>
                                <p class="text-amber-800 dark:text-amber-200 mb-3">These tasks were not completed and will be carried over to the next sprint:</p>
                                <div class="space-y-2">
                                    ${sprintResult.carriedOverTasks.map(task => `
                                        <div class="bg-white dark:bg-gray-750 p-2 rounded flex justify-between items-center border-l-4 border-amber-400">
                                            <span>${task.name}</span>
                                            <span class="font-semibold">${task.remainingPoints} pts remaining</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Prepare strategies list
            let strategiesHtml = '';
            if (sprintResult.strategies.length > 0) {
                strategiesHtml = '<div class="flex flex-wrap gap-2">';
                sprintResult.strategies.forEach(strategy => {
                    strategiesHtml += `<span class="px-3 py-1 bg-primary/10 text-primary rounded-full text-sm">${strategy}</span>`;
                });
                strategiesHtml += '</div>';
            } else {
                strategiesHtml = '<p class="text-gray-700 dark:text-gray-300 italic">No strategies were selected for this sprint</p>';
            }
            
            // Prepare reworked tasks section
            let reworkedHtml = '';
            if (sprintResult.reworkedTasks > 0) {
                reworkedHtml = `
                    <div class="bg-rose-50 dark:bg-rose-900/20 p-4 rounded-lg mb-6">
                        <div class="flex items-start">
                            <div class="text-rose-700 dark:text-rose-300 mr-3 mt-1">
                                <i class="fas fa-sync-alt"></i>
                            </div>
                            <div>
                                <h4 class="font-semibold text-rose-700 dark:text-rose-300 mb-2">Task Rework</h4>
                                <p class="text-rose-800 dark:text-rose-200">
                                    ${sprintResult.reworkedTasks} task(s) needed to be reworked to meet your Definition of Done.
                                    ${sprintResult.reworkedTasks > 2 ? 'Consider improving quality checks earlier in the development process.' : ''}
                                </p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Prepare feedback based on results
            let feedback = '';
            if (completionPercentage >= 80) {
                feedback = 'Excellent job! Your team successfully completed most of the planned work.';
            } else if (completionPercentage >= 60) {
                feedback = 'Good effort. Your team completed a significant portion of the planned work.';
            } else if (completionPercentage >= 40) {
                feedback = 'Mixed results. Your team completed some work but fell short of expectations.';
            } else {
                feedback = 'Challenging sprint. Your team struggled to complete the planned work.';
            }
            
            // Add retrospective decisions section
            let retrospectiveHtml = '';
            if (gameState.retrospectiveDecisions.sprintLength !== 14) {
                retrospectiveHtml += `
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg mb-3">
                        <div class="flex items-center text-blue-700 dark:text-blue-300">
                            <i class="fas fa-calendar-alt mr-2"></i>
                            <span class="font-semibold">Sprint Length Change:</span>
                        </div>
                        <p class="text-blue-800 dark:text-blue-200 mt-1">
                            Next sprint length increased to ${gameState.retrospectiveDecisions.sprintLength} days 
                            (was ${sprintResult.sprintLength} days)
                        </p>
                    </div>
                `;
            }
            
            if (gameState.retrospectiveDecisions.teamChanges) {
                retrospectiveHtml += `
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg mb-3">
                        <div class="flex items-center text-blue-700 dark:text-blue-300">
                            <i class="fas fa-users-cog mr-2"></i>
                            <span class="font-semibold">Team Changes:</span>
                        </div>
                        <p class="text-blue-800 dark:text-blue-200 mt-1">
                            The team will be modified before the next sprint
                        </p>
                    </div>
                `;
            }
            
            if (gameState.retrospectiveDecisions.processChanges) {
                retrospectiveHtml += `
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
                        <div class="flex items-center text-blue-700 dark:text-blue-300">
                            <i class="fas fa-sync-alt mr-2"></i>
                            <span class="font-semibold">Process Changes:</span>
                        </div>
                        <p class="text-blue-800 dark:text-blue-200 mt-1">
                            Process improvements will be implemented in the next sprint
                        </p>
                    </div>
                `;
            }
            
            // Only show retrospective section if there are changes
            const retrospectiveSection = retrospectiveHtml ? `
                <div class="mb-6">
                    <h3 class="font-bold mb-3">Retrospective Decisions</h3>
                    ${retrospectiveHtml}
                </div>
            ` : '';
            
            // Definition of Done section
            const dodSection = sprintResult.definitionOfDone ? `
                <div class="mb-6">
                    <h3 class="font-bold mb-3">Definition of Done</h3>
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-3 rounded-lg">
                        <div class="flex items-center text-blue-700 dark:text-blue-300">
                            <i class="fas fa-check-square mr-2"></i>
                            <span class="font-semibold">Current Definition:</span>
                        </div>
                        <div class="mt-1 text-blue-800 dark:text-blue-200">
                            <p>It can't have any unresolved high-severity defects</p>
                            <p>${sprintResult.definitionOfDone}</p>
                        </div>
                    </div>
                </div>
            ` : '';
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Sprint ${sprintResult.sprint} Summary</h2>
                            <p class="text-gray-700 dark:text-gray-300">Review your team's performance</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-semibold">
                                Sprint Score: <span>${sprintResult.score}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mb-6">
                        <h3 class="font-bold mb-4">Sprint Performance</h3>
                        
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h4 class="font-semibold mb-2 text-primary">Story Points</h4>
                                <div class="flex justify-between mb-1 text-sm">
                                    <span>Assigned:</span>
                                    <span>${sprintResult.assignedPoints}</span>
                                </div>
                                <div class="flex justify-between mb-1 text-sm">
                                    <span>Completed:</span>
                                    <span class="font-semibold">${sprintResult.completedPoints}</span>
                                </div>
                                <div class="flex justify-between mb-1 text-sm">
                                    <span>Unassigned:</span>
                                    <span>${sprintResult.unassignedPoints}</span>
                                </div>
                                <div class="mt-3">
                                    <div class="flex justify-between text-sm mb-1">
                                        <span>Completion:</span>
                                        <span>${completionPercentage}%</span>
                                    </div>
                                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                        <div class="bg-primary rounded-full h-2" style="width: ${completionPercentage}%"></div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h4 class="font-semibold mb-2 text-primary">Quality</h4>
                                <div class="text-center mb-3">
                                    <div class="inline-flex items-center justify-center rounded-full bg-white dark:bg-gray-700 w-24 h-24 border-4 border-primary">
                                        <span class="text-2xl font-bold">${sprintResult.quality}%</span>
                                    </div>
                                </div>
                                <div class="text-sm">
                                    ${sprintResult.quality >= 90 ? 
                                        '<p class="text-green-600 dark:text-green-400">Excellent quality! Very few bugs and high customer satisfaction.</p>' :
                                        sprintResult.quality >= 75 ?
                                        '<p class="text-blue-600 dark:text-blue-400">Good quality with minor issues that can be easily fixed.</p>' :
                                        sprintResult.quality >= 60 ?
                                        '<p class="text-amber-600 dark:text-amber-400">Acceptable quality but several issues need attention.</p>' :
                                        '<p class="text-red-600 dark:text-red-400">Poor quality with significant bugs and issues.</p>'
                                    }
                                </div>
                            </div>
                            
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg">
                                <h4 class="font-semibold mb-2 text-primary">Team Morale</h4>
                                <div class="text-center mb-3">
                                    <div class="inline-flex items-center justify-center rounded-full bg-white dark:bg-gray-700 w-24 h-24 border-4 ${
                                        sprintResult.teamMorale >= 80 ? 'border-green-500' :
                                        sprintResult.teamMorale >= 60 ? 'border-blue-500' :
                                        sprintResult.teamMorale >= 40 ? 'border-amber-500' : 'border-red-500'
                                    }">
                                        <span class="text-2xl font-bold">${sprintResult.teamMorale}%</span>
                                    </div>
                                </div>
                                <div class="text-sm">
                                    ${sprintResult.teamMorale >= 80 ? 
                                        '<p class="text-green-600 dark:text-green-400">The team is highly motivated and enthusiastic!</p>' :
                                        sprintResult.teamMorale >= 60 ?
                                        '<p class="text-blue-600 dark:text-blue-400">Team morale is good, but could be improved.</p>' :
                                        sprintResult.teamMorale >= 40 ?
                                        '<p class="text-amber-600 dark:text-amber-400">Team is feeling some pressure and stress.</p>' :
                                        '<p class="text-red-600 dark:text-red-400">Team morale is low, burnout risk is high.</p>'
                                    }
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg mb-4">
                            <div class="flex items-start">
                                <div class="text-blue-700 dark:text-blue-300 mr-3 text-xl">
                                    <i class="fas fa-comment-alt"></i>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-blue-700 dark:text-blue-300 mb-1">Sprint Feedback</h4>
                                    <p class="text-blue-800 dark:text-blue-200">${feedback}</p>
                                </div>
                            </div>
                        </div>
                        
                        ${reworkedHtml}
                        ${carriedOverHtml}
                        
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h4 class="font-semibold mb-3">Completed Products</h4>
                                ${completedProductsHtml}
                            </div>
                            <div>
                                <h4 class="font-semibold mb-3">Sprint Strategies</h4>
                                ${strategiesHtml}
                            </div>
                        </div>
                    </div>
                    
                    ${dodSection}
                    
                    ${retrospectiveSection}
                    
                    <div class="flex justify-between mt-8">
                        <button id="view-team" class="btn btn-secondary">
                            View Team
                        </button>
                        <button id="next-sprint" class="btn btn-primary">
                            ${gameState.currentSprint < gameState.totalSprints - 1 ? 'Plan Next Sprint' : 'Final Results'}
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            document.getElementById('view-team').addEventListener('click', () => {
                renderPhase('teamSelection');
            });
            
            document.getElementById('next-sprint').addEventListener('click', () => {
                if (gameState.currentSprint < gameState.totalSprints - 1) {
                    gameState.currentSprint++;
                    renderPhase('backlogSelection');
                } else {
                    // Calculate final score
                    calculateFinalScore();
                    renderPhase('final');
                }
            });
        }

        // Calculate final game score
        function calculateFinalScore() {
            // Sum up sprint scores
            let totalScore = gameState.sprintResults.reduce((sum, result) => sum + result.score, 0);
            
            // Bonus for team morale at the end
            const finalMorale = gameState.sprintResults[gameState.sprintResults.length - 1].teamMorale;
            if (finalMorale >= 80) {
                totalScore = Math.floor(totalScore * 1.2); // 20% bonus for high morale
            } else if (finalMorale >= 60) {
                totalScore = Math.floor(totalScore * 1.1); // 10% bonus for good morale
            } else if (finalMorale < 30) {
                totalScore = Math.floor(totalScore * 0.8); // 20% penalty for very low morale
            }
            
            gameState.finalScore = totalScore;
        }

        // Render Final Summary Phase
        function renderFinalSummaryPhase(container) {
            // Calculate total story points completed across all sprints
            const totalCompletedPoints = gameState.sprintResults.reduce((sum, result) => sum + result.completedPoints, 0);
            
            // Calculate average quality across all sprints
            const averageQuality = Math.round(
                gameState.sprintResults.reduce((sum, result) => sum + result.quality, 0) / gameState.sprintResults.length
            );
            
            // Calculate total products completed
            const completedProducts = [].concat(...gameState.sprintResults.map(result => result.completedProducts));
            const uniqueCompletedProducts = [...new Map(completedProducts.map(item => [item.id, item])).values()];
            
            // Calculate total reworked tasks
            const totalReworked = gameState.sprintResults.reduce((sum, result) => sum + (result.reworkedTasks || 0), 0);
            
            // Prepare sprint comparison data
            const sprintLabels = gameState.sprintResults.map(result => `Sprint ${result.sprint}`);
            const sprintPoints = gameState.sprintResults.map(result => result.completedPoints);
            const sprintQuality = gameState.sprintResults.map(result => result.quality);
            const sprintMorale = gameState.sprintResults.map(result => result.teamMorale);
            
            // Generate performance feedback
            let feedback;
            if (gameState.finalScore >= 300) {
                feedback = 'Outstanding performance! Your team delivered exceptional value with high quality and maintained excellent team morale.';
            } else if (gameState.finalScore >= 200) {
                feedback = 'Great job! Your team successfully delivered valuable features while maintaining good quality and team morale.';
            } else if (gameState.finalScore >= 100) {
                feedback = 'Good effort. Your team delivered some value, but there\'s room for improvement in productivity, quality, or team morale.';
            } else {
                feedback = 'Challenging project. Your team struggled to deliver value. Consider reviewing your team composition and strategies for future projects.';
            }
            
            container.innerHTML = `
                <div class="fade-in">
                    <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                        <div>
                            <h2 class="text-2xl font-bold mb-1">Final Project Results</h2>
                            <p class="text-gray-700 dark:text-gray-300">Summary of your team's performance across all sprints</p>
                        </div>
                        <div class="mt-4 md:mt-0 panel-blue">
                            <div class="text-blue-800 dark:text-blue-200 font-bold text-xl">
                                Final Score: <span>${gameState.finalScore}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mb-6">
                        <h3 class="font-bold mb-4">Project Performance</h3>
                        
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg text-center">
                                <h4 class="font-semibold mb-2 text-primary">Story Points Completed</h4>
                                <div class="text-3xl font-bold mb-1">${totalCompletedPoints}</div>
                                <p class="text-sm text-gray-700 dark:text-gray-300">across all sprints</p>
                            </div>
                            
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg text-center">
                                <h4 class="font-semibold mb-2 text-primary">Average Quality</h4>
                                <div class="text-3xl font-bold mb-1">${averageQuality}%</div>
                                <p class="text-sm text-gray-700 dark:text-gray-300">across all deliverables</p>
                            </div>
                            
                            <div class="bg-gray-50 dark:bg-gray-800 p-3 rounded-lg text-center">
                                <h4 class="font-semibold mb-2 text-primary">Products Completed</h4>
                                <div class="text-3xl font-bold mb-1">${uniqueCompletedProducts.length}</div>
                                <p class="text-sm text-gray-700 dark:text-gray-300">out of ${productBacklogItems.length} total</p>
                            </div>
                        </div>
                        
                        <div class="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg mb-6">
                            <div class="flex items-start">
                                <div class="text-green-700 dark:text-green-300 mr-3 text-xl">
                                    <i class="fas fa-trophy"></i>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-green-700 dark:text-green-300 mb-1">Project Feedback</h4>
                                    <p class="text-green-800 dark:text-green-200">${feedback}</p>
                                </div>
                            </div>
                        </div>
                        
                        ${totalReworked > 0 ? `
                        <div class="bg-rose-50 dark:bg-rose-900/20 p-4 rounded-lg mb-6">
                            <div class="flex items-start">
                                <div class="text-rose-700 dark:text-rose-300 mr-3 text-xl">
                                    <i class="fas fa-sync-alt"></i>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-rose-700 dark:text-rose-300 mb-1">Task Rework Summary</h4>
                                    <p class="text-rose-800 dark:text-rose-200">
                                        Your team had to rework ${totalReworked} tasks across all sprints to meet the Definition of Done requirements.
                                        ${totalReworked > 5 ? 'This indicates a need for better quality control earlier in the development process.' : 
                                          totalReworked > 2 ? 'A moderate amount of rework is common, but try to catch issues earlier next time.' : 
                                          'You managed to keep rework to a minimum, which is excellent!'}
                                    </p>
                                </div>
                            </div>
                        </div>
                        ` : ''}
                        
                        <div class="mb-6">
                            <h4 class="font-semibold mb-3">Sprint Comparison</h4>
                            <div class="bg-gray-50 dark:bg-gray-800 p-4 rounded-lg">
                                <div class="overflow-x-auto">
                                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                                        <thead>
                                            <tr>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Sprint</th>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Story Points</th>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Quality</th>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Team Morale</th>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Reworked Tasks</th>
                                                <th class="px-4 py-2 text-left font-semibold text-gray-700 dark:text-gray-300">Score</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
                                            ${gameState.sprintResults.map(result => `
                                                <tr>
                                                    <td class="px-4 py-2">Sprint ${result.sprint}</td>
                                                    <td class="px-4 py-2">${result.completedPoints}</td>
                                                    <td class="px-4 py-2">${result.quality}%</td>
                                                    <td class="px-4 py-2">${result.teamMorale}%</td>
                                                    <td class="px-4 py-2">${result.reworkedTasks || 0}</td>
                                                    <td class="px-4 py-2 font-semibold">${result.score}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="font-semibold mb-3">Completed Products</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                                ${uniqueCompletedProducts.map(product => {
                                    const reworkCount = gameState.reworkCount[product.id] || 0;
                                    return `
                                        <div class="bg-gray-50 dark:bg-gray-800 p-2 rounded-lg flex justify-between items-center ${reworkCount > 0 ? 'border-l-4 border-rose-400 dark:border-rose-600' : ''}">
                                            <div>
                                                <span>${product.name}</span>
                                                ${reworkCount > 0 ? `<span class="ml-2 text-xs text-rose-600 dark:text-rose-400">(Reworked ${reworkCount}x)</span>` : ''}
                                            </div>
                                            <span class="font-semibold">${product.storyPoints} pts</span>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                    
                    <div class="flex justify-between mt-8">
                        <button id="view-summary" class="btn btn-secondary">
                            View Sprint Summary
                        </button>
                        <button id="restart-game" class="btn btn-primary">
                            Start New Game
                        </button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            document.getElementById('view-summary').addEventListener('click', () => {
                renderPhase('summary');
            });
            
            document.getElementById('restart-game').addEventListener('click', () => {
                initializeGame();
                reset_sprint_len();
            });
        }

        // Show notification toast
        function showNotification(message, type = 'info') {
            // Remove any existing notifications
            const existingNotification = document.getElementById('notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.id = 'notification';
            notification.className = `fixed bottom-4 right-4 px-4 py-2 rounded-lg shadow-lg transition-all transform translate-y-0 ${
                type === 'error' ? 'bg-red-500 text-white' :
                type === 'success' ? 'bg-green-500 text-white' :
                'bg-blue-500 text-white'
            }`;
            notification.style.zIndex = '1000';
            notification.innerHTML = message;
            
            // Add to body
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-y-20', 'opacity-0');
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 3000);
        }

        // Initialize event listeners for the game
        function initializeEventListeners() {
            document.addEventListener('click', (e) => {
                // Event option handlers
                if (e.target.classList.contains('event-option') || e.target.parentElement?.classList.contains('event-option')) {
                    const optionElement = e.target.classList.contains('event-option') ? e.target : e.target.parentElement;
                    const optionId = optionElement.getAttribute('data-id');
                    const eventId = gameState.currentEvent.id;
                    handleEventResponse(eventId, optionId);
                }
            });
        }

        // Initialize the game
        initializeGame();
        initializeEventListeners();
        reset_sprint_len();
    </script>
</body>
</html>
